<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo + GitHub 博客搭建</title>
      <link href="/2022/12/01/hexo-github-bo-ke-da-jian/"/>
      <url>/2022/12/01/hexo-github-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-GitHub-博客搭建"><a href="#Hexo-GitHub-博客搭建" class="headerlink" title="Hexo + GitHub 博客搭建"></a>Hexo + GitHub 博客搭建</h1><p>前置条件</p><p>1、首先要有一个github账号 </p><p>2、其次安装node.js，npm依赖 </p><p>3、然后安装git工具 </p><h4 id="1、Git的安装："><a href="#1、Git的安装：" class="headerlink" title="1、Git的安装："></a>1、Git的安装：</h4><p>你可在git官网中根据自己的需要进行下载：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>打开之后你将看到如下内容，无电脑<code>download for Windows</code>：</p><p>将其下载到指定的磁盘，然后Windows系统下傻瓜式安装即可。安装好后我们打开cmd终端（win+r </p><p>-&gt; 输入cmd -&gt; 回车），执行<code>git --version</code>，若出现<code>git version 2.19.2.windows.1</code>之类的版输</p><p>出，那么恭喜你已经成功安装，离完成建站近了一步。</p><h4 id="2、Node-js的安装："><a href="#2、Node-js的安装：" class="headerlink" title="2、Node.js的安装："></a>2、Node.js的安装：</h4><p>Hexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。</p><p><strong>windows：</strong>下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。</p><p>最后安装好之后，按Win+R打开命令提示符，输入node -v 和 npm -v，如果出现版本号，那么就安装</p><p>成功了。</p><p>安装完后，打开命令行终端，输入:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-v</span><span class="token function">npm</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>检查一下有没有安装成功</p><h4 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h4><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的</p><p>博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>比如我的博客文件都存放在D:\Study\Blog目录下。</p><p>在该目录下右键点击Git Bash Here，打开git的控制台窗口，操作都在git控制台进行。</p><p>① 定位到该目录下，输入<code>npm install -g hexo-cli</code>安装<code>Hexo</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>至此<code>hexo</code>就安装完了。</p><p>② 接下来初始化一下<code>hexo</code>,即初始化我们的网站，进入我们主题根目录Hexo，输入<code>hexo init</code>初始化文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个Hexo可以自己取什么名字都行，然后，接着输入<code>npm install</code>安装必备的组件。</p><p>新建完成后，指定文件夹<code>Hexo</code>目录下有：</p><ul><li><code>node_modules:</code> 依赖包</li><li><code>public：</code>存放生成的页面</li><li><code>scaffolds：</code>生成文章的一些模板</li><li><code>source：</code>用来存放你的文章</li><li><code>themes：</code>主题**</li><li><code>_config.yml:</code> 博客的配置文件**</li></ul><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011050698.png"></p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h4 id="4-注册Github账号创建个人仓库"><a href="#4-注册Github账号创建个人仓库" class="headerlink" title="4. 注册Github账号创建个人仓库"></a>4. 注册<a href="https://so.csdn.net/so/search?q=Github&spm=1001.2101.3001.7020">Github</a>账号创建个人仓库</h4><p>打开自己的<a href="https://github.com/">https://github.com/</a>，新建一个项目仓库<code>New repository</code></p><p>注意！！！仓库名称一定得是xxx.github.io</p><blockquote><p>要创建一个和你用户名相同的仓库，后面加.<code>http://github.io</code>，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是<code>http://xxxx.github.io</code>，其中xxx就是你注册GitHub的用户名。例如我的：<code>http://Jovinbin.github.io</code></p></blockquote><h4 id="5-生成SSH添加到GitHub"><a href="#5-生成SSH添加到GitHub" class="headerlink" title="5. 生成SSH添加到GitHub"></a>5. 生成SSH添加到GitHub</h4><p>生成<code>SSH</code>添加到<code>GitHub</code>，连接<code>Github</code>与本地。</p><p>右键打开<code>git bash</code>，然后输入下面命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"yourname"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：第一次使用git后需要将用户名和邮箱进行初始化</p><p>这里的<code>yourname</code>输入你的<code>GitHub</code>用户名，<code>youremail</code>输入你<code>GitHub</code>的邮箱。这样<code>GitHub</code>才能知</p><p>道你是不是对应它的账户。例如我的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"zjb"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"1097204334@qq.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后创建<code>SSH</code>,一路回车</p><blockquote><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候会生成.ssh文件夹。在git bash中输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>打开<a href="http://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便取</p><p>一个都可以，把你的<code>id_rsa.pub</code>里面的信息复制进去。如图：</p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011051050.png" alt="image-20221201105100011"></p><p>在<code>git bash</code>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011051865.png" alt="image-20221201105121836"></p><h4 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6. 将hexo部署到GitHub"></a>6. 将hexo部署到GitHub</h4><p>这一步，我们就可以将<code>hexo</code>和<code>GitHub</code>关联起来，也就是将<code>hexo</code>生成的文章部署到<code>GitHub</code>上，打开</p><p>博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种</p><p>信息。</p><p>修改最后一行的配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repository</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/gaoziman/gaoziman.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>repository</code>修改为你自己的<code>github</code>项目地址即可就是部署时，告诉工具，将生成网页通过<code>git</code>方式</p><p>上传到你对应的链接仓库中。</p><p>这个时候需要先安装<code>deploy-git</code> ，也就是部署的命令,这样你才能用命令部署到<code>GitHub</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后执行如下命令：其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。 <code>hexo generate</code>顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写 ，<code>hexo deploy</code>部署文章，可以用<code>hexo d</code>缩写</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>得到下图就说明部署成功了，过一会儿就可以在<a href="http://jovinbin.github.io/">http://Jovinbin.github.io</a> 这个网站看到你的博客了！！</p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011051077.png" alt="image-20221201105148431"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Doris随笔</title>
      <link href="/2022/11/18/doris-xue-xi-bi-ji/"/>
      <url>/2022/11/18/doris-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Doris（PB级别数据库）"><a href="#Doris（PB级别数据库）" class="headerlink" title="Doris（PB级别数据库）"></a>Doris（PB级别数据库）</h1><p>mysql -h localhost -P9030 -u -p</p><h5 id="①-查看表结构"><a href="#①-查看表结构" class="headerlink" title="① 查看表结构"></a><strong>① 查看表结构</strong></h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">desc table （all）;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>② 通过命令查看完成状态</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW ALTER TABLE ROLLUP;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>③ 查看动态分区表调度情况</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW DYNAMIC PARTITION TABLES; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>④ 查看表的分区</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW PARTITIONS FROM TABLES;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>⑤ 查看物化视图是否创建成功</strong> (Version 0.13)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW ALTER TABLE MATERIALIZED VIEW FROM test_db;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>⑥ 删除物化视图</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP MATERIALIZED VIEW 物化视图名 on Base 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>⑦ 创建物化索引</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create materialized view mv_1 as select store_id,record_id,seller_id, sale_date,sale_amt from sales_records;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>⑧ 修改名字 </p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE table1 RENAME table2;ALTER TABLE example_table RENAME ROLLUP rollup1 rollup2;ALTER TABLE example_table RENAME PARTITION p1 p2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑨ 导入链路相关命令</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">查看导入：show load order by createtime desc limit 1\G；    show load；取消导入：CANCEL LOAD [FROM db_name] WHERE LABEL&#x3D;”load_label”; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>⑩ routine load 导入任务</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">展示导入任务：show routine load\G;暂停名称为 test1 的例行导入作业：PAUSE ROUTINE LOAD FOR test1;暂停所有正在运行的例行导入作业：PAUSE ALL ROUTINE LOAD;恢复名称为 test1 的例行导入作业：RESUME ROUTINE LOAD FOR test1;恢复所有暂停中的例行导入作业：RESUME ALL ROUTINE LOAD;停止名称为 test1 的例行导入作业：STOP ROUTINE LOAD FOR test1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⭕ <strong>查看数据库信息</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show proc &quot;&#x2F;statistic&quot;；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>⭕<strong>查看信息</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW PROC &#39;&#x2F;dbs&#39;;SHOW PROC &#39;&#x2F;dbs&#x2F;11048&#x2F;32003&#x2F;partitions&#x2F;32131&#x2F;32004&#39;;show proc &quot;&#x2F;cluster_balance&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>索引</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">创建索引：CREATE INDEX table_bitmap ON table1 (siteid) USING BITMAP COMMENT  &#39;table1_bitmap_index&#39;; 查看索引：SHOW INDEX[ES] FROM [db_name.]table_name [FROM database]; 或者 SHOW KEY[S] FROM [db_name.]table_name [FROM database]; 删除索引：DROP INDEX IF EXISTS table_bitmap ON test_db.table1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常用命令</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">查看配置信息：show variables;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​Doris 的架构很简洁，只设 FE(Frontend)、BE(Backend)两种角色、两个进程，<strong>不依赖于</strong> </p><p><strong>外部组件</strong>，方便部署和运维，FE、BE 都可线性扩展。 </p><p>⚫   <strong>FE（Frontend）</strong>：存储、维护集群<strong>元数据</strong>；负责接收、解析查询请求，规划查询计划， 调度查询执行，返回查询结果。主要有三个角色： </p><p>​（1）Leader 和 Follower：主要是用来达到元数据的高可用，保证单节点宕机的情况下， </p><p>元数据能够实时地在线恢复，而不影响整个服务。 </p><p>​（2）Observer：用来扩展查询节点，同时起到元数据备份的作用。如果在发现集群压力 </p><p>非常大的情况下，需要去扩展整个查询的能力，那么可以加 observer 的节点。observer 不 </p><p>参与任何的写入，只参与读取。</p><p>⚫ <strong>BE（Backend）</strong>：负责<strong>物理数据的存储和计算</strong>；依据 FE 生成的物理计划，分布式地执行查询。 </p><p>​数据的可靠性由 BE 保证，BE 会对整个数据存储多副本或者是三副本。副本数可根据 </p><p>需求动态调整。 </p><p><strong>1、sql查看状态</strong>（mysql -h hadoop1 -P 9030 -uroot -p）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW PROC &#39;&#x2F;backends&#39;;查看BE状态SHOW PROC &quot;&#x2F;brokers&quot;;查看broker状态SHOW PROC &#39;&#x2F;frontends&#39;;查看FE状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.2.2 Partition &amp; Tablet</strong> </p><p>​在 Doris 的存储引擎中，用户数据首先被划分成若干个分区（Partition），划分的规则通 常是按照用户指定的分区列进行范围划分，比如按时间划分。而在每个分区内，数据被进一 步的按照 Hash 的方式分桶，分桶的规则是要找用户指定的分桶列的值进行 Hash 后分桶。 每个分桶就是一个数据分片（Tablet），也是数据划分的最小逻辑单元。 </p><p>⚫ Tablet 之间的数据是没有交集的，独立存储的。Tablet 也是数据移动、复制等操作 </p><p>的最小物理存储单元。 </p><p>⚫ Partition 可以视为是逻辑上最小的管理单元。数据的导入与删除，都可以或仅能针 </p><p>对一个 Partition 进行</p><p><strong>3.4.1</strong> <strong>列定义</strong> </p><p>​以 AGGREGATE KEY 数据模型为例进行说明。更多数据模型参阅 Doris 数据模型。 列的基本类型，可以通过在 mysql-client 中执行 HELP CREATE TABLE; 查看。 AGGREGATE KEY 数据模型中，所有没有指定聚合方式（SUM、REPLACE、MAX、 MIN）的列视为 Key 列。而其余则为 Value 列。 定义列时，可参照如下建议： </p><p>➢ Key 列必须在所有 Value 列之前。 </p><p>➢ 尽量选择整型类型。因为整型类型的计算和查找比较效率远高于字符串。 </p><p>➢ 对于不同长度的整型类型的选择原则，遵循够用即可。 </p><p>➢ 对于 VARCHAR 和 STRING 类型的长度，遵循 够用即可。 </p><p>➢ 所有列的总字节长度（包括 Key 和 Value）不能超过 100KB。</p><p><strong>3.4.2</strong> <strong>分区与分桶</strong> </p><p>​Doris 支持两层的数据划分。第一层是 Partition，支持 Range 和 List 的划分方式。第二 层是 Bucket（Tablet），仅支持 Hash 的划分方式。 也可以仅使用一层分区。使用一层分区时，只支持 Bucket 划分。</p><p><strong>3.4.2.1 Partition</strong> </p><p>➢ Partition 列可以指定一列或多列。分区类必须为 KEY 列。多列分区的使用方式在后面介绍。 </p><p>➢ 不论分区列是什么类型，在写分区值时，都需要加<strong>双引号</strong>。 </p><p>➢ 分区数量理论上没有上限。 </p><p>➢ 当不使用 Partition 建表时，系统会自动生成一个和表名同名的，全值范围的 Partition。该 Partition 对用户不可见，并且不可删改。 </p><p><strong>1）Range 分区</strong> （动态分区列数据不能为Date）</p><p>​分区列通常为时间列，以方便的管理新旧数据。不可添加范围重叠的分区。</p><p><strong>2）List 分区</strong> </p><p>​分 区 列支 持 BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, LARGEINT, DATE,  DATETIME, CHAR, VARCHAR 数据类型，分区值为枚举值。只有当数据为目标分区枚举值其中之一时，才可以命中分区。不可添加范围重叠的分区。</p><p><strong>3.4.2.2 Bucket</strong> </p><p>（1）如果使用了 Partition，则 DISTRIBUTED … 语句描述的是数据在各个分区内的划 </p><p>分规则。如果不使用 Partition，则描述的是对整个表的数据的划分规则。 </p><p>（2）分桶列可以是多列，但<strong>必须为</strong> <strong>Key</strong> <strong>列</strong>。分桶列可以和 Partition 列相同或不同。 </p><p>（3）分桶列的选择，是在 查询吞吐 和 查询并发 之间的一种权衡： </p><p>​① 如果选择多个分桶列，则数据分布更均匀。 </p><p>​如果一个查询条件不包含所有分桶列的等值条件，那么该查询会触发所有分桶同时 </p><p>扫描，这样查询的吞吐会增加，单个查询的延迟随之降低。这个方式适合大吞吐低并发 </p><p>的查询场景。 </p><p>​② 如果仅选择一个或少数分桶列，则对应的点查询可以仅触发一个分桶扫描。 </p><p>​此时，当多个点查询并发时，这些查询有较大的概率分别触发不同的分桶扫描，各 </p><p>个查询之间的 IO 影响较小（尤其当不同桶分布在不同磁盘上时），所以这种方式适合 </p><p>高并发的点查询场景。 </p><p>（4）分桶的数量理论上没有上限。 </p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011054585.png" alt="image-20221201105403532"></p><p><strong>3.7 Rollup</strong> （rollup可以调整列的顺序，调整前缀索引的顺序）</p><p>​ROLLUP 在多维分析中是“上卷”的意思，即将数据按某种指定的粒度进行进一步聚合。 </p><p><strong>3.7.4 ROLLUP</strong> <strong>的几点说明</strong> </p><p>⚫ ROLLUP 最根本的作用是提高某些查询的查询效率（无论是通过聚合来减少数据 量，还是修改列顺序以匹配前缀索引）。因此 ROLLUP 的含义已经超出了“上卷” 的范围。这也是为什么在源代码中，将其命名为 Materialized Index（物化索引）的 原因。</p><p>⚫ ROLLUP 是附属于 Base 表的，可以看做是 Base 表的一种辅助数据结构。用户可以在 Base表的基础上，创建或删除 ROLLUP，但是不能在查询中显式的指定查询某 </p><p>ROLLUP。是否命中 ROLLUP 完全由 Doris 系统自动决定。 </p><p>⚫ ROLLUP 的数据是独立物理存储的。因此，创建的 ROLLUP 越多，占用的磁盘空间也就越大。同时对导入速度也会有影响（导入的 ETL 阶段会自动产生所有ROLLUP 的数据），但是不会降低查询效率（只会更好）。 </p><p>⚫ ROLLUP 的数据更新与 Base 表是完全同步的。用户无需关心这个问题。 </p><p>⚫ ROLLUP 中列的聚合方式，与 Base 表完全相同。在创建 ROLLUP 无需指定，也不能修改。 </p><p>⚫ 查询能否命中 ROLLUP 的一个必要条件（非充分条件）是，查询所涉及的所有列（包括 select list 和 where 中的查询条件列等）都存在于该 ROLLUP 的列中。否则，查询只能命中 Base 表。 </p><p>⚫ 某些类型的查询（如 count(*)）在任何条件下，都无法命中 ROLLUP。具体参见接下来的聚合模型的局限性一节。 </p><p>⚫ 可以通过 EXPLAIN your_sql; 命令获得查询执行计划，在执行计划中，查看是否命 中 ROLLUP。 </p><p>⚫ 可以通过 DESC tbl_name ALL; 语句显示 Base 表和所有已创建完成的 ROLLUP。</p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011054941.png" alt="image-20221201105432908"></p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011054412.png" alt="image-20221201105453371"></p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011055054.png" alt="image-20221201105515015"></p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011055372.png" alt="image-20221201105535322"></p><p>2）Observer：用来扩展查询节点，同时起到元数据备份的作用。如果在发现集群压力 </p><p>非常大的情况下，需要去扩展整个查询的能力，那么可以加 observer 的节点。observer 不 </p><p>参与任何的写入，只参与读取。 </p><p>⚫ <strong>BE<strong><strong>（</strong></strong>Backend****）</strong>：负责<strong>物理数据的存储和计算</strong>；依据 FE 生成的物理计划，分布式地执</p>]]></content>
      
      
      <categories>
          
          <category> Doris </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Doris </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
