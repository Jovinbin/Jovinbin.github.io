<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java学习笔记</title>
      <link href="/2023/02/22/java-xue-xi-bi-ji/"/>
      <url>/2023/02/22/java-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><h4 id="1、-面向对象和面向过程的区别？"><a href="#1、-面向对象和面向过程的区别？" class="headerlink" title="1、 面向对象和面向过程的区别？"></a>1、 面向对象和面向过程的区别？</h4><blockquote><p>​面向对象就是高度实物抽象化、面向过程就是自顶向下的编程！</p><p>​<strong>面向过程</strong>：优点是性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。而Linux\Unix等一般采用面向过程开发，性能是最重要的因素。缺点是没有面向对象易维护，易复用，易扩展。可维护性差，不易修改。</p><p>​<strong>面向对象</strong>：优点是易维护，易复用，易扩展。由于面向对象由封装，继承，多态性的特性，可以设计出耦合度低的系统，使系统更加灵活，更加易于维护。 缺点是性能比面向过程低。</p></blockquote><h4 id="2、关于JDK、JRE和JVM的看法？"><a href="#2、关于JDK、JRE和JVM的看法？" class="headerlink" title="2、关于JDK、JRE和JVM的看法？"></a>2、关于JDK、JRE和JVM的看法？</h4><blockquote><p>JDK包括Java虚拟机（JVM）、Java编译器（Javac）、Java归档文件（JAR）、Java文档（Javadoc）等。</p><p>JRE包括Java虚拟机（JVM）、运行时类库、执行Java字节码所需要的Java应用程序启动器，但省略了Java编译器等开发工具。</p><p>JDK包含了JRE，JRE包含了JDK。</p></blockquote><h4 id="3、字符型常量和字符串常量的区别？"><a href="#3、字符型常量和字符串常量的区别？" class="headerlink" title="3、字符型常量和字符串常量的区别？"></a>3、字符型常量和字符串常量的区别？</h4><blockquote><ul><li><p>形式不同：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符</p></li><li><p>含义上：字符常量相当于一个整型值(ASCII值)，可以参与表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置)</p></li><li><p>占内存大小：字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</p></li></ul></blockquote><h4 id="4、什么是字符串常量池？"><a href="#4、什么是字符串常量池？" class="headerlink" title="4、什么是字符串常量池？"></a>4、什么是字符串常量池？</h4><blockquote><p>​字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p></blockquote><h4 id="5、构造器Constructor是否可被override？"><a href="#5、构造器Constructor是否可被override？" class="headerlink" title="5、构造器Constructor是否可被override？"></a>5、构造器Constructor是否可被override？</h4><p>不能被override（重写），但是可以被overload（重载）</p><p>Constructor 不能被继承, 所以不能被 override。</p><blockquote><p>构造器是用来干什么的：是用来生成一个类的实例，是用来初始化这个实例的。</p><p>构造器如何工作？</p><p>Java在构造实例时的顺序：</p><ul><li>分配对象空间，并将对象中成员初始化为零或空，Java不允许用户操纵一个不定值的对象</li><li>执行属性值的显式初始化</li><li>执行构造器</li><li>将变量关联到堆中的对象上</li></ul><p>而执行构造器的步骤又可以分为以下五步：</p><ul><li>分配参数给指定的构造函数</li><li>如果这个指定的构造函数的第一个语句使用this指针显示的调用本类的其他构造函数，则递归执行这5个步骤，如果执行过程正常则跳到步骤5</li><li>如果构造函数的第一个语句没有显式调用本类的其他构造函数，并且本类不是Object类（Object是所有类的父类，而它自己没有父类），则调用显式（super指针）或隐式的指定的父类的构造函数，递归执行这5个步骤，如果执行过程正常则跳到步骤5</li><li>执行这个构造函数中余下的语句，如果执行过程正常则过程结束</li></ul></blockquote><h4 id="6、重载和重写的区别？"><a href="#6、重载和重写的区别？" class="headerlink" title="6、重载和重写的区别？"></a>6、重载和重写的区别？</h4><blockquote><ul><li>定义不同：重载是定义相同的方法名，参数不同；重写是子类重写父类的方法</li><li>范围不同：重载是在一个类中；重写是子类与父类之间的</li><li>多态不同：重载是编译时的多态性；重写是运行时的多态性</li><li>返回不同：重载对返回类型没有要求；重写要求返回类型，有兼容的返回类型</li><li>参数不同：重载的参数个数、参数类型、参数顺序可以不同；重写父子方法参数必须相同</li><li>修饰不同：重载对访问修饰没有特殊要求；重写访问修饰符的限制一定要大于被重写的方法的访问修饰符</li></ul></blockquote><h4 id="7、Java面向对象编程三大特性：封装、继承、多态"><a href="#7、Java面向对象编程三大特性：封装、继承、多态" class="headerlink" title="7、Java面向对象编程三大特性：封装、继承、多态"></a>7、Java面向对象编程三大特性：封装、继承、多态</h4><blockquote><p><strong>封装</strong>：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p><p><strong>继承</strong>：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特 性的基础上进行扩展，增加新功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。<strong>继承主要解决的问题是：共性的抽取，实现代码复用。</strong></p><p><strong>多态</strong>：多态可以理解在继承的状态下，多个子类的行为都具有父类的行为特征，我们可以直接使用父类去指向子类对象，使父类对象可以指向不同的子类对象，调用方法时有多样的变化。</p></blockquote><h4 id="8、String、StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？"><a href="#8、String、StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="8、String、StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？"></a>8、String、StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？</h4><blockquote><p><strong>可变性</strong>：</p><ul><li>String内部实现其实是<code>private final char value[]</code>, 所以String对象是不可变的；</li><li>StringBuilder与StringBuffer都继承自AbstractStringBuilder类.AbstractStringBuilder是用<code>char[] value</code>来存储字符串的, 但是没有用final关键字, 所以StringBuilder和StringBuffer对象都是可变的</li></ul><p><strong>线程安全性</strong>：</p><ul><li>String中的对象是不可变的, 可以理解成常量, 是线程安全的；</li><li>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁, 所以是线程安全的</li><li>StringBuilder并没有对方法家同步锁, 所以是非线程安全的</li></ul><p><strong>性能</strong>：</p><ul><li>对于String对象而言, 每次都会生成一个新的String对象, 然后将指针指向新的String对象</li><li>StringBuffer和StringBuilder每次都会对对象本身进行操作, 而不是生成新的对象并且改变对象的引用. 相同情况下使用StringBuilder会比StringBuffer获得10%-15%的性能提升, 但是要承担多线程不安全的风险</li></ul><p>注：</p><ul><li>少量数据用String</li><li>单线程大量数据用StringBuilder</li><li>多线程大量数据用StringBuffer</li></ul></blockquote><h4 id="9、自动拆箱与装箱"><a href="#9、自动拆箱与装箱" class="headerlink" title="9、自动拆箱与装箱"></a>9、自动拆箱与装箱</h4><blockquote><p>int和Integer的区别</p><ul><li>Integer是int的包装类；int是基本数据类型；</li><li>Integer变量必须实例化后才能使用；int变量不需要；</li><li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li><li>Integer的默认值是null；int的默认值是0。</li></ul><p>jdk1.5 开始引入了自动装箱&#x2F;拆箱机制</p><ul><li><p><strong>自动装箱：将基本数据类型重新转化为对象</strong></p></li><li><p><strong>自动拆箱：将对象重新转化为基本数据类型</strong></p></li></ul></blockquote><h3 id="二、Java集合"><a href="#二、Java集合" class="headerlink" title="二、Java集合"></a>二、Java集合</h3><h4 id="1、说说List、Set、Map三者的区别？"><a href="#1、说说List、Set、Map三者的区别？" class="headerlink" title="1、说说List、Set、Map三者的区别？"></a>1、说说List、Set、Map三者的区别？</h4><blockquote><ul><li>List：是有序集合，可以存储重复的元素。List中的每一个元素都有一个对应的整数的索引，通过索引可以访问、插入、替换和删除元素。常用的List实现类有ArrayList和LinkedList。</li><li>Set：是无序集合，不可以存储重复元素。Set中的元素没有顺序，不能通过索引访问，但可以添加、查询、删除元素。常用的Set实现类有HashSet和TreeSet，其中 HashSet 基于哈希表实现，支持快速插入和查询操作；TreeSet 基于红黑树实现，支持有序集合操作，如查询最小值、最大值、前驱、后继等。</li><li>Map：是键值对集合，其中每个元素都是一个键值对。Map中的键是唯一的，但值可以重复。可以通过键来访问、插入、替换和删除对应的值。常用的Map实现类有HashMap和TreeMap，其中 HashMap 基于哈希表实现，支持快速插入和查询操作；TreeMap 基于红黑树实现，支持有序键值对操作，如查询最小键值对、最大键值对、前驱键值对、后继键值对等。</li></ul><p>三者的主要区别在于：有序&#x2F;无序、可重复&#x2F;不可重复、是否支持索引&#x2F;键值对等操作。</p></blockquote><h4 id="2、ArrayList和LinkedList的区别？"><a href="#2、ArrayList和LinkedList的区别？" class="headerlink" title="2、ArrayList和LinkedList的区别？"></a>2、ArrayList和LinkedList的区别？</h4><blockquote><ul><li><p>底层数据结构：</p><p>ArrayList基于动态数组实现，底层使用数组存储元素。数组的大小可以动态扩容，当数组容量不足时，会自动扩展数组的长度，以适应更多的元素。</p><p>LinkedList基于双向链表实现，底层使用链表存储元素。链表的每个节点包含元素值和指向下一个节点的指针。</p></li><li><p>插入和删除操作</p><p>由于 ArrayList 基于数组实现，插入和删除元素时需要移动后面的元素，因此在存储大量元素时，插入和删除操作的效率可能较低。而 LinkedList 基于链表实现，插入和删除元素时只需要修改节点的指针，因此在存储大量元素时，插入和删除操作的效率可能更高。</p></li><li><p>内存占用</p><p>ArrayList 和 LinkedList 的内存占用不同。由于 ArrayList 基于数组实现，所以它需要预分配一段连续的内存空间，因此在存储大量元素时，可能会浪费一些内存空间。而 LinkedList 不需要预分配连续的内存空间，每个元素都存储在单独的节点中，因此它可以更好地利用内存空间。</p></li><li><p>随机访问</p><p>由于 ArrayList 基于数组实现，它支持快速随机访问元素，即通过索引可以在 O(1) 的时间复杂度内访问元素。而 LinkedList 不支持随机访问，需要从头节点开始遍历链表，直到找到目标节点。</p></li></ul><p>综上所述，ArrayList 和 LinkedList 的选择取决于实际需求。如果需要快速随机访问元素，可以选择 ArrayList；如果需要频繁插入和删除元素，可以选择 LinkedList。</p></blockquote><h4 id="3、ArrayList和Vector区别？为什么要用ArrayList取代Vector呢？"><a href="#3、ArrayList和Vector区别？为什么要用ArrayList取代Vector呢？" class="headerlink" title="3、ArrayList和Vector区别？为什么要用ArrayList取代Vector呢？"></a>3、ArrayList和Vector区别？为什么要用ArrayList取代Vector呢？</h4><blockquote><ul><li><p>线程安全性</p><p>Vector是线程安全的，ArrayList是非线程安全的。</p></li><li><p>效率</p><p>ArrayList速度更快，没有进行额外的线程安全检查。</p></li></ul><p>目前，由于 Java 提供了更为高效的线程安全机制，如 ConccurentHashMap、ConcurrentSkipListMap 和 CopyOnWriteArrayList 等，所以在绝大多数情况下，使用 ArrayList 取代 Vector 是一个更好的选择。这也是为什么在 JDK 1.5 之后，Java 推荐使用 ArrayList，而不是 Vector。</p></blockquote><h4 id="4、说一说ArrayList的扩容机制？"><a href="#4、说一说ArrayList的扩容机制？" class="headerlink" title="4、说一说ArrayList的扩容机制？"></a>4、说一说ArrayList的扩容机制？</h4><blockquote><ul><li><p>初始容量</p><p>当创建一个新的ArrayList对象时，需要为其指定初始容量，如果没有指定，默认初始容量为10。</p></li><li><p>自动扩容</p><p>当向 ArrayList 中添加元素时，如果元素个数大于等于数组容量（也就是当前 ArrayList 的 size() 大于等于它的 capacity），就需要扩容。ArrayList 扩容的规则是，每次将当前数组容量增加1.5倍，同时将原数组中的元素复制到新数组中。这个过程会使用 System.arraycopy() 函数来进行数组的复制操作，这个操作时间复杂度为 O(n)。</p></li><li><p>指定初始容量</p><p>如果事先能够估算出 ArrayList 中元素的数量，可以在创建 ArrayList 对象时就指定一个足够大的初始容量，可以避免在添加元素时进行频繁的扩容操作，提高程序的效率。</p></li></ul><p>注意：需要注意的是，ArrayList 的扩容机制在处理大量数据时可能会带来一些性能问题，因为扩容操作需要重新分配更大的内存空间，并将原来的数据复制到新的内存空间中，这个过程可能会比较耗时。因此，在处理大量数据时，建议事先估算好数据量，并设置一个合适的初始容量，以减少扩容次数。</p></blockquote><h4 id="5、HashMap和HashTable的区别？"><a href="#5、HashMap和HashTable的区别？" class="headerlink" title="5、HashMap和HashTable的区别？"></a>5、HashMap和HashTable的区别？</h4><blockquote><ul><li><p>线程安全性</p><p>HashMap非线程安全，HashTable线程安全</p></li><li><p>null值处理</p><p>HashTable不允许key或value为空，否则会抛出空指针异常，HashMap可以允许key或value为空</p></li><li><p>初始容量和扩容机制</p><p>HashTable的初始容量默认为11，负载因子默认0.75。HashMap的初始容量默认为16，负载因子默认为0.75。当哈希表中的元素数量超过了负载因子和容量的乘积时，就会自动扩容</p></li><li><p>性能</p><p>HashTable的方法被synchronized 关键字修饰，会带来一定的性能开销。比HashMap慢</p></li></ul></blockquote><h4 id="6、HashSet如何检查重复？"><a href="#6、HashSet如何检查重复？" class="headerlink" title="6、HashSet如何检查重复？"></a>6、HashSet如何检查重复？</h4><blockquote><p>HashSet是Java中的一种集合类，底层是基于HashMap实现的。在HashSet中，元素是无序的、不可重复的。</p><p>HashSet是通过对元素进行哈希操作来判断是否重复的。当我们向HashSet中添加一个元素时，HashSet会首先计算该元素的哈希码（hash code），然后将哈希码作为key，将元素本身作为value，将其存储到底层的HashMap中。如果在添加新元素时发现该元素的哈希码已经在HashMap中存在，那么HashSet会比较新元素和已有元素的equals方法返回值是否为true，如果是，则认为新元素重复了，不再添加到集合中。</p></blockquote><h4 id="7、HashMap的底层实现？"><a href="#7、HashMap的底层实现？" class="headerlink" title="7、HashMap的底层实现？"></a>7、HashMap的底层实现？</h4><blockquote><p>Java中的HashMap是一种基于哈希表实现的键值对（key-value）映射数据结构，它使用哈希函数将key映射到数组中的位置，从而实现快速的插入、删除和查找操作。</p><p>HashMap的底层实现是一个数组（table），数组中的每个元素是一个链表或红黑树（JDK1.8及以上版本），用于存储相同哈希值的key-value对。在JDK1.8之前，如果同一个哈希值的key-value对的数量超过了一个阈值（默认为8），就会将这些元素存储在一个链表中，而JDK1.8及以上版本引入了红黑树来优化这种情况，提高了查找效率。</p><p>需要注意的是，HashMap的实现不是线程安全的，如果在多线程环境中使用HashMap，需要采取相应的措施来保证线程安全，例如使用ConcurrentHashMap，或者使用锁来保护HashMap的操作。</p></blockquote><h4 id="8、HashMap多线程的操作导致死循环问题？"><a href="#8、HashMap多线程的操作导致死循环问题？" class="headerlink" title="8、HashMap多线程的操作导致死循环问题？"></a>8、HashMap多线程的操作导致死循环问题？</h4><blockquote><p>在多线程环境下，如果对HashMap进行不当的操作，可能会导致HashMap的内部数据结构发生破坏，从而导致死循环或其他问题。</p><p>具体来说，如果多个线程同时对HashMap进行修改操作，例如put或remove，可能会导致其中一个线程正在执行的操作影响到其他线程，从而导致内部数据结构的破坏。例如，如果多个线程同时对同一个桶（bucket）进行操作，可能会导致链表中的元素出现断裂，从而导致死循环等问题。</p><p>另外，由于HashMap不是线程安全的，如果在多线程环境中同时进行读写操作，也可能会导致数据不一致的问题，例如读取到过时的数据或者写入失败等。</p><p>为了避免这些问题，可以采取以下几种措施：</p><ul><li>使用线程安全的Map实现，例如ConcurrentHashMap，这些实现使用了锁机制或其他并发控制手段，可以保证多线程环境下的安全访问；</li><li>在多线程环境下使用synchronized或者Lock等同步机制来保护HashMap的访问；</li><li>在多线程环境下只进行读取操作，避免对HashMap进行写操作；</li><li>在多线程环境下对HashMap进行分段或分片，使得每个线程只对特定的区域进行操作，从而避免竞争和冲突。</li></ul></blockquote><h4 id="9、ConcurrentHashMap和HashTable的区别？"><a href="#9、ConcurrentHashMap和HashTable的区别？" class="headerlink" title="9、ConcurrentHashMap和HashTable的区别？"></a>9、ConcurrentHashMap和HashTable的区别？</h4><blockquote><ul><li><p>同步机制的不同</p><p>HashTable使用synchronized关键字对整个Hashtable对象进行同步，即每个线程访问Hashtable时都需要获取对象级别的锁，这会影响并发性能。而ConcurrentHashMap使用了分段锁的机制，将Map分成多个Segment（段），每个Segment都是一个独立的HashTable，只对Segment进行加锁，这样多个线程可以同时访问不同的Segment，从而提高并发性能。</p></li><li><p>扩容机制的不同</p><p>HashTable在进行扩容时会将整个HashTable锁住，这样在扩容期间其他线程无法访问HashTable，从而影响并发性能。而ConcurrentHashMap可以进行动态扩容，并且不会锁住整个Map，只需要对正在扩容的Segment加锁，其他Segment仍然可以被并发访问。</p></li><li><p>空值的支持</p><p>HashTable不支持null值作为key或value，任何null值的插入都会抛出NullPointerException异常。而ConcurrentHashMap可以支持null值作为key或value。</p></li><li><p>遍历方式的不同</p><p>Hashtable的遍历方式是Enumeration，而ConcurrentHashMap是通过Iterator或者forEach进行遍历。</p></li><li><p>性能的不同</p><p>由于ConcurrentHashMap使用了分段锁的机制，可以在多线程并发访问时提高并发性能，因此通常比HashTable具有更好的性能。</p></li></ul></blockquote><h4 id="10、ConcurrentHashMap线程安全的具体实现方式-x2F-底层具体实现？"><a href="#10、ConcurrentHashMap线程安全的具体实现方式-x2F-底层具体实现？" class="headerlink" title="10、ConcurrentHashMap线程安全的具体实现方式&#x2F;底层具体实现？"></a>10、ConcurrentHashMap线程安全的具体实现方式&#x2F;底层具体实现？</h4><blockquote><ul><li><p>分段锁机制：ConcurrentHashMap内部将Map划分为一定数量的Segment（段），每个Segment维护一个散列表。在默认情况下，ConcurrentHashMap会根据CPU的核数来确定Segment的数量。不同线程对不同Segment的访问是互相独立的，因此可以提高并发访问性能。</p></li><li><p>CAS（Compare and Swap）机制：ConcurrentHashMap在并发修改Map的过程中，使用CAS操作来保证数据的一致性和线程安全。CAS操作可以避免使用锁机制带来的性能损失，并且可以保证数据的一致性。</p></li></ul><p>具体来说，ConcurrentHashMap中每个Segment内部使用ReentrantLock（可重入锁）来保证线程安全，在修改数据时获取Segment对应的锁。而在查询数据时，ConcurrentHashMap可以同时访问所有Segment中的数据，因此可以提高查询性能。</p><p>在具体实现中，ConcurrentHashMap还使用了volatile关键字、Unsafe类等技术来确保数据的可见性和操作的原子性。同时，为了避免死锁的发生，ConcurrentHashMap在内部使用了一个”死亡节点”（Dead Node）来处理锁的释放。</p><p>总的来说，ConcurrentHashMap的线程安全是通过分段锁机制和CAS机制相结合来实现的，这种机制可以在保证线程安全的同时提高并发访问性能，是Java并发编程中常用的高性能数据结构之一。</p></blockquote><h4 id="11、Comparable和Comparator的区别"><a href="#11、Comparable和Comparator的区别" class="headerlink" title="11、Comparable和Comparator的区别"></a>11、Comparable和Comparator的区别</h4><blockquote><p>Comparable是Java内置的接口，它在类内部实现，允许在一个类中实现自然排序。一个类实现了Comparable接口后，就可以使用Arrays.sort()和Collections.sort()等排序方法对类的实例进行排序。当然，需要注意的是，使用Comparable进行排序时，只能进行一种排序方式。</p><p>Comparator接口是Java提供的用于定义排序顺序的一种方法。Comparator允许在单独的类中定义排序顺序，这样可以对多个类进行同一种排序。Comparator接口有一个方法：compare(Object o1, Object o2)，该方法返回一个整数值，如果o1小于o2，返回负数；如果o1等于o2，返回0；如果o1大于o2，返回正数。与Comparable不同的是，Comparator可以实现多种排序方式，因此我们可以通过实现不同的Comparator来对同一个类的实例进行不同的排序。</p><p>Comparable接口的实现是固定的，无法在运行时修改。而Comparator接口的实现是灵活的，可以在运行时根据需要创建多个比较器对象来对不同的对象进行排序。</p></blockquote><h3 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h3><h4 id="1、什么是多线程？"><a href="#1、什么是多线程？" class="headerlink" title="1、什么是多线程？"></a>1、什么是多线程？</h4><blockquote><p>在Java中，多线程是指在同一时间内，有多个线程在并发的执行代码。每个线程都拥有自己的执行堆栈和程序计数器，并且可以独立的执行。多线程编程允许我们同时处理多个任务，从而提高程序的执行效率和影响力。</p></blockquote><h4 id="2、请简要描述线程与进程的关系，区别及优点？"><a href="#2、请简要描述线程与进程的关系，区别及优点？" class="headerlink" title="2、请简要描述线程与进程的关系，区别及优点？"></a>2、请简要描述线程与进程的关系，区别及优点？</h4><blockquote><p>线程和进程都是操作系统中用于并发执行程序的概念。</p><p>进程是一个正在执行中的程序实例。它拥有自己的地址空间、内存、文件句柄和其他系统资源。每个进程都有一个唯一的进程标识符（PID）。在操作系统中，进程是资源分配和调度的基本单位。</p><p>线程是进程中的执行单元。一个进程可以包含多个线程，这些线程共享同一个地址空间、内存和其他系统资源。每个线程有自己的执行堆栈和程序计数器，但共享同一个进程的堆空间。在操作系统中，线程是调度的基本单位，它比进程更轻量级，创建和销毁线程的代价也更小。</p><p>区别：</p><ul><li>进程是操作系统资源分配的最小单位，而线程是进程中执行的最小单位。</li><li>进程之间相互独立，互不干扰，而线程之间共享进程的资源，彼此之间可以互相通信和协作。</li><li>进程拥有独立的地址空间，而线程共享进程的地址空间。</li><li>进程之间切换的开销比线程之间的开销大得多，进程间通信的代价也比线程间通信的代价大。</li></ul><p>优点：</p><ul><li>多进程可以更好地利用多核CPU的计算能力，提高程序的并行性和吞吐量；</li><li>多线程可以减少创建和销毁线程的开销，同时也可以更好地利用单核CPU的计算能力，提高程序的响应速度和效率。</li></ul></blockquote><h4 id="3、说说并发与并行的区别？"><a href="#3、说说并发与并行的区别？" class="headerlink" title="3、说说并发与并行的区别？"></a>3、说说并发与并行的区别？</h4><blockquote><p>并发（concurrency）指的是在同一时间段内，有多个任务在交替地执行。这些任务可能在同一个进程中，也可能在不同的进程中。在并发执行的任务中，它们的执行是相互独立的，彼此之间没有直接的影响，但是它们可能会共享同一些资源（如内存、文件等），这就需要进行资源共享和同步。</p><p>并行（parallelism）指的是在同一时间段内，有多个任务同时执行。这些任务可以在多个CPU、多核处理器或者多台计算机上并行执行，相互之间不会有任何干扰。在并行执行的任务中，它们的执行是同时进行的，不需要进行资源共享和同步。</p><p>区别：</p><ul><li><p>并发和并行都是在同一时间段内执行多个任务，但是并发是交替执行的，而并行是同时执行的。</p></li><li><p>并发通常是在单个CPU上实现的，通过时间分片的方式来交替执行多个任务，而并行是在多个CPU或多核CPU上实现的。</p></li><li><p>并发需要进行资源共享和同步，因为多个任务可能会共享同一些资源，而并行不需要进行资源共享和同步。</p></li></ul></blockquote><h4 id="4、为什么要使用多线程呢？"><a href="#4、为什么要使用多线程呢？" class="headerlink" title="4、为什么要使用多线程呢？"></a>4、为什么要使用多线程呢？</h4><blockquote><ul><li>提高程序的响应速度</li><li>提高程序的性能</li><li>提高资源利用率</li><li>改善用户体验</li></ul></blockquote><h4 id="5、使用多线程可能带来什么问题？"><a href="#5、使用多线程可能带来什么问题？" class="headerlink" title="5、使用多线程可能带来什么问题？"></a>5、使用多线程可能带来什么问题？</h4><blockquote><ul><li><p>线程安全问题：由于多个线程访问共享资源，可能会导致数据的不一致性或者丢失。这需要使用同步机制来保证线程安全。</p></li><li><p>死锁问题：当多个线程相互等待对方释放资源的时候，可能会导致死锁，从而导致程序无法继续执行。这需要使用正确的锁机制来避免死锁问题。</p></li><li><p>上下文切换问题：由于CPU需要在多个线程之间切换执行，这会导致一定的时间开销。如果线程数量过多，会导致上下文切换的开销过大，影响程序的性能。</p></li><li><p>资源竞争问题：由于多个线程可能同时竞争一些资源，如文件、网络连接、数据库连接等，可能会导致资源的浪费或者瓶颈。这需要使用正确的资源管理和调度机制来避免资源竞争问题。</p></li><li><p>线程阻塞问题：当一个线程因为某个资源而阻塞时，会导致程序的响应速度变慢。这需要使用异步编程技术来避免线程阻塞问题。</p></li></ul></blockquote><h4 id="6、说说线程的生命周期和状态？"><a href="#6、说说线程的生命周期和状态？" class="headerlink" title="6、说说线程的生命周期和状态？"></a>6、说说线程的生命周期和状态？</h4><blockquote><p>线程的生命周期可以分为五个状态：新建、就绪、运行、阻塞、死亡。</p><ol><li>新建状态：当线程对象被创建时，线程处于新建状态。此时线程并没有启动，它只是一个Java对象。</li><li>就绪状态：当线程调用 start() 方法后，线程处于就绪状态。此时线程已经被系统分配到了CPU资源，但是还没有开始执行。</li><li>运行状态：当线程获得CPU时间片并开始执行时，线程处于运行状态。此时线程正在执行代码。</li><li>阻塞状态：当线程因为某些原因不能执行时，线程处于阻塞状态。例如，线程等待某个输入、输出操作完成、请求某个锁、等待某个条件满足等。在这种状态下，线程不会占用CPU时间，直到它被唤醒。</li><li>终止状态：当线程完成了它的任务或者出现了异常时，线程处于终止状态。此时线程不再执行，也不占用CPU时间。</li></ol></blockquote><h4 id="7、什么是线程死锁？如何避免死锁？"><a href="#7、什么是线程死锁？如何避免死锁？" class="headerlink" title="7、什么是线程死锁？如何避免死锁？"></a>7、什么是线程死锁？如何避免死锁？</h4><blockquote><p>线程死锁是指两个或多个线程在互相等待对方释放锁时，形成了一种僵局，导致线程无法继续执行。一般来说，线程死锁的发生是由于以下四个必要条件同时满足造成的：</p><ol><li>互斥条件：资源只能被同一个线程占用，如果一个线程已经占用了资源，其他线程就必须等待该线程释放资源。</li><li>请求与保持条件：一个线程持有某个资源的同时，又请求获取其他资源，而这些资源可能正被其他线程占用。</li><li>不剥夺条件：资源只能由占用它的线程释放，其他线程无法强制占用该资源。</li><li>循环等待条件：若干线程之间形成一种循环等待资源的关系，形成闭环，导致线程无法继续执行。</li></ol><p>为了避免线程死锁，我们可以采用以下几种策略：</p><ol><li>避免使用多个锁：如果每个线程只需要一个锁，那么死锁的概率就会大大降低。如果必须使用多个锁，可以按照一定的顺序获取锁，从而避免死锁。</li><li>及时释放锁：当线程使用完共享资源后，应该及时释放锁，避免占用锁的时间过长，导致其他线程长时间等待。</li><li>死锁检测：可以使用一些工具或算法来检测死锁的发生，并及时采取措施来避免死锁的发生。</li><li>破坏循环等待条件：可以采用一些方法来破坏循环等待条件，例如按序申请资源、限制资源申请次数、强制释放资源等。</li></ol></blockquote><h4 id="8、说说sleep-方法和wait-方法区别和共同点？"><a href="#8、说说sleep-方法和wait-方法区别和共同点？" class="headerlink" title="8、说说sleep()方法和wait()方法区别和共同点？"></a>8、说说sleep()方法和wait()方法区别和共同点？</h4><blockquote><p>区别：</p><ol><li>sleep()方法和wait()方法的使用对象不同。sleep()方法是Thread类的静态方法，可以直接使用，而wait()方法是Object类的实例方法，只能在synchronized代码块中使用。</li><li>sleep()方法是线程休眠一段时间后继续执行，不会释放持有锁。wait()方法会让线程暂时释放持有的锁并进入等待队列，知道被唤醒后才会重新竞争锁。</li><li>sleep()方法可以在任何地方使用，而wait()方法必须在同步块中使用，因为wait()方法需要先获取对象的监视器才能等待和被唤醒。</li></ol><p>共同点：</p><ol><li>sleep()方法和wait()方法都可以用于线程的暂停和唤醒。</li><li>sleep()方法和wait()方法都会抛出InterruptedException异常，当线程在等待或睡眠状态中被中断时抛出。</li><li>sleep()方法和wait()方法都需要指定等待时间，sleep()方法指定的是休眠时间，wait()方法指定的是等待时间。</li><li>sleep()方法和wait()方法都会使线程进入阻塞状态。</li></ol></blockquote><h4 id="9、为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用-run-方法？"><a href="#9、为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="9、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用.run()方法？"></a>9、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用.run()方法？</h4><blockquote><p>在Java中，当我们创建一个线程并调用它的start()方法时，系统会在新线程中执行run()方法。这是因为start()方法会为新线程分配资源并启动它，使其进入就绪状态，并开始执行run()方法。这个过程需要操作系统和Java虚拟机的配合完成，包括为新线程分配栈空间、保存线程上下文等操作。</p><p>相反，如果我们直接调用run()方法，这只是普通的方法调用，并不会启动一个新的线程。run()方法将在当前线程中执行，而不是在新的线程中执行。也就是说，线程并没有并发执行，而是顺序执行了run()方法。这种情况与创建一个新线程的目的相悖，因为我们通常创建线程是为了并发执行任务，以提高程序的效率和性能。如果我们直接调用run()方法，就无法实现这个目的。</p><p>因此，正确的方式是通过调用start()方法来启动一个新线程，并在新线程中执行run()方法，从而实现多线程并发执行的目的。</p></blockquote><h4 id="10、说一说自己对synchronized关键字的了解"><a href="#10、说一说自己对synchronized关键字的了解" class="headerlink" title="10、说一说自己对synchronized关键字的了解"></a>10、说一说自己对synchronized关键字的了解</h4><blockquote><p>synchronized是Java中的一个关键字，用于保护共享资源并确保多线程下的安全性。当多个线程需要访问同一共享资源时，使用synchronized关键字可以防止出现竟态条件，从而避免数据的不一致性和线程安全问题。</p><p>具体来说，synchronized关键字可以作用于以下两个方面：</p><ol><li>同步方法：可以将synchronized关键字应用于整个方法上，表示该方法为同步方法。当一个线程进入同步方法时，他会获取该方法所属对象的锁，其他线程将会被阻塞，直到当前线程释放锁。</li><li>同步代码块：可以将synchronized关键字应用于某个代码块上，表示该代码块为同步代码块。同步代码块的锁对象可以是任何一个对象，包括this对象。当一个线程进入同步代码块时，它会获取该锁对象的锁，其他线程将会被阻塞，直到当前线程释放锁。</li></ol><p>synchronized关键字的使用可以有效地保护共享资源并确保线程安全，但是也有一些注意点：</p><ol><li>synchronized关键字会降低程序的性能，因为多个线程在获取锁时可能会发生竞争和阻塞。</li><li>需要注意死锁的情况，即两个或多个线程相互等待对方释放锁而无法继续执行的情况。为避免死锁，应该避免在同步块中嵌套同步块，或者在同步块中调用其他对象的同步方法。</li><li>在使用synchronized关键字时，应该遵循同步代码块越小越好的原则，以减少锁的竞争和阻塞，提高程序的并发性能。</li></ol></blockquote><h4 id="11、什么是上下文切换"><a href="#11、什么是上下文切换" class="headerlink" title="11、什么是上下文切换"></a>11、什么是上下文切换</h4><blockquote><p>在多线程环境下，线程是操作系统调度的最小单位，而上下文切换也是在线程之间进行的。当操作系统需要切换线程时，它会保存当前线程的上下文信息，包括线程的程序计数器、栈指针、寄存器值、线程状态等，并将这些信息保存到内存中。然后，操作系统会从就绪队列中选择另一个线程并恢复其上下文信息，CPU继续执行新的线程。这个过程就是多线程的上下文切换。</p><p>与单线程的上下文切换相比，多线程的上下文切换需要保存和恢复更多的上下文信息，因为每个线程都有自己的程序计数器、栈、寄存器等，而且它们共享进程的地址空间和系统资源。因此，多线程的上下文切换通常比单线程的上下文切换更耗费时间和系统资源，尤其是在高并发的多线程应用中。</p><p>为了避免过多的上下文切换，可以采用以下策略：</p><ol><li>使用线程池来重复使用线程，避免频繁创建和销毁线程。</li><li>减少锁的竞争，避免线程之间的等待，以减少上下文切换的次数。</li><li>使用非阻塞式I&#x2F;O操作，避免线程的I&#x2F;O等待时间，以提高并发性能。</li><li>使用适当的调度算法，如先来先服务、时间片轮转、优先级调度等，以最大限度地减少上下文切换的次数。</li></ol></blockquote><h3 id="四、线程池"><a href="#四、线程池" class="headerlink" title="四、线程池"></a>四、线程池</h3><h4 id="1、什么是线程池？"><a href="#1、什么是线程池？" class="headerlink" title="1、什么是线程池？"></a>1、什么是线程池？</h4><blockquote><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p></blockquote><h4 id="2、为什么要用线程池？"><a href="#2、为什么要用线程池？" class="headerlink" title="2、为什么要用线程池？"></a>2、为什么要用线程池？</h4><blockquote><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性：无限制的创建线程，不仅会消耗系统的资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul></blockquote><h4 id="3、如何创建线程池？"><a href="#3、如何创建线程池？" class="headerlink" title="3、如何创建线程池？"></a>3、如何创建线程池？</h4><blockquote><ul><li><p>通过<code>ThreadPoolExecutor</code>构造函数创建（推荐）;</p></li><li><p>通过<code>Executor</code>框架的工具类<code>Executor</code>来创建</p><ul><li><p><strong><code>FixedThreadPool</code></strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p><p><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p><p><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p><p><strong><code>ScheduledThreadPool</code></strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</p></li></ul></li></ul></blockquote><h4 id="4、线程池常见参数有哪些？如何解释？"><a href="#4、线程池常见参数有哪些？如何解释？" class="headerlink" title="4、线程池常见参数有哪些？如何解释？"></a>4、线程池常见参数有哪些？如何解释？</h4><blockquote><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><code>corePoolSize</code>（核心线程数）：任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><code>maxPoolSize</code>（最大线程数）：任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><code>queueCapacity</code>（消息队列数量）：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><code>keepAliveSeconds</code>（存活时间）：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><code>rejectedExecutionHandler</code>（拒绝策略）<ul><li><code>ThreadPoolExecutor.AbortPolicy</code>： 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>： 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：*不处理新任务，直接丢弃掉。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li></ul></li></ul></blockquote><h4 id="5、线程池处理任务的流程？"><a href="#5、线程池处理任务的流程？" class="headerlink" title="5、线程池处理任务的流程？"></a>5、线程池处理任务的流程？</h4><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202302231553018.png" alt="image-20230223155345913"></p><ul><li>如果当前运行的线程数小于核心线程数，那么就会创建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数量是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ul><h3 id="五、JVM"><a href="#五、JVM" class="headerlink" title="五、JVM"></a>五、JVM</h3><h4 id="1、介绍下Java内存区域（运行时数据区）"><a href="#1、介绍下Java内存区域（运行时数据区）" class="headerlink" title="1、介绍下Java内存区域（运行时数据区）"></a>1、介绍下Java内存区域（运行时数据区）</h4><blockquote><p>Java内存区域（运行时数据区）是指在Java虚拟机中用来存储程序执行期间的数据的区域，Java虚拟机规范将其划分为以下五个区域：</p><ol><li>程序计数器：是一块较小的内存区域，用于指示JVM正在执行的字节码指令的地址。由于Java虚拟机采用的是线程轮流切换执行的方式，因此每个线程都要有一个独立的程序计数器，各个线程之间互不干扰，独立存储，这也是为什么Java虚拟机规范中把程序计数器定义为线程私有的原因。</li><li>Java虚拟机栈：Java虚拟机栈是线程私有的，它描述的是Java方法执行的内存模型，而每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、</li><li>操作数栈、动态链接、方法出口等信息。当方法执行完毕时，栈帧被销毁，这个过程对应着方法的出栈（pop）操作。</li><li>堆（Heap）：堆是 Java 虚拟机中最大的一块内存区域，也是所有线程共享的一块内存区域。在虚拟机启动时就已经创建，用于存储对象实例和数组，几乎所有的对象实例都在这里分配内存。堆的大小可以通过 -Xmx 和 -Xms 参数来指定，如果堆中没有足够的空间进行对象分配，则会触发垃圾回收（GC）。</li><li>方法区（Method Area）：方法区也是所有线程共享的一块内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码等数据。虽然方法区也被称为永久代（Permanent Generation），但是在 JDK 8 中已经被彻底移除，用元空间（Metaspace）代替了永久代的实现。</li><li>运行时常量池（Runtime Constant Pool）：运行时常量池是方法区的一部分，用于存储编译期间生成的字面量和符号引用，这些内容在类加载后会被放到运行时常量池中。在运行期间，如果需要使用常量池中的内容，就直接从运行时常量池中取出即可。</li></ol><p>除了以上五个区域，Java虚拟机中还有直接内存和本地方法栈。</p></blockquote><h4 id="2、说一下Java对象的创建过程"><a href="#2、说一下Java对象的创建过程" class="headerlink" title="2、说一下Java对象的创建过程"></a>2、说一下Java对象的创建过程</h4><blockquote><ol><li>类加载：在Java程序运行时，Java虚拟机首先要加载对象所属的类。这个过程中，Java虚拟机会在类路径下搜索并找到对象所属的类文件，并将其加载到内存中。</li><li>分配内存：在类加载完成后，Java虚拟机会为对象分配内存。Java对象在内存中的分配时通过“new”关键字实现的，这时候Java虚拟机会为对象分配足够的内存空间，以存储对象的成员变量。</li><li>初始化：内存分配完成后，Java虚拟机会自动为对象的成员变量附默认值，例如int类型的成员变量会被赋值为0，引用类型的成员变量会被赋值为null。如果对象的类中定义了构造函数，Java虚拟机会调用构造函数堆成员变量进行初始化。</li><li>设置对象的引用：Java虚拟机在创建对象的同时，还会在堆中为该对象分配一个唯一的引用值。这个引用值被赋值给对象的引用变量，这样程序就可以通过引用变量来操作对象了。</li><li>返回对象的引用：在对象创建完成后，Java虚拟机会返回对象的引用给程序。程序可以通过这个引用来访问对象成员变量和方法。</li></ol></blockquote><h4 id="3、对象的访问定位有哪两种方式"><a href="#3、对象的访问定位有哪两种方式" class="headerlink" title="3、对象的访问定位有哪两种方式"></a>3、对象的访问定位有哪两种方式</h4><blockquote><ol><li>引用变量：程序可以通过引用变量来访问对象的成员变量和方法。在Java中，每个对象都有唯一的引用值，这个引用值被赋值给对象的引用变量，通过引用变量就可以访问对象的成员变量和方法。</li><li>对象的this指针：在Java中，每一个对象都有一个隐含的this指针，代表对象本身。this指针可以在对象内部使用，用来访问对象的成员变量和方法。例如，在一个类的方法中，可以通过this指针来访问该对象的成员变量和方法。</li></ol></blockquote><h4 id="4、说一下堆内存中对象的分配的基本策略"><a href="#4、说一下堆内存中对象的分配的基本策略" class="headerlink" title="4、说一下堆内存中对象的分配的基本策略"></a>4、说一下堆内存中对象的分配的基本策略</h4><blockquote><ol><li>标记-清楚算法：是一种基本的垃圾回收算法。在这种算法中，首先会扫描堆中的所有对象，将存活的对象打上标记，然后将未标记的对象视为垃圾，进行清除。这种算法的缺点是会产生大量的存储碎片，从而导致内存空间的利用率降低。</li><li>分代收集算法：分代收集算法是一种更加高效的垃圾回收算法。在这种算法中，Java堆被划分为新生代和老年代两个部分。新生代中的对象一般存活时间比较短，因此使用复制算法进行垃圾回收；而老年代中的对象一般存活时间比较长，因此使用标记-清除算法或标记-整理算法进行垃圾回收。这种算法的优点是可以有效地减少内存碎片，提高内存空间的利用率。</li></ol></blockquote><h4 id="5、Minor-GC和Full-GC有什么不同"><a href="#5、Minor-GC和Full-GC有什么不同" class="headerlink" title="5、Minor GC和Full GC有什么不同"></a>5、Minor GC和Full GC有什么不同</h4><blockquote><p>在Java中，垃圾收集（GC）时自动进行的，主要用于释放不再使用的内存空间。垃圾收集器主要分为Minor GC和Full GC两种，它们的不同点如下：</p><ol><li>触发时机不同：Minor GC发生在新生代，用于回收新生代中不再使用的对象，而Full GC发生在老年代，用于回收老年代中不再使用的对象。</li><li>回收的对象不同：Minor GC主要回收新生代中的对象，它会将存活的对象复制到另一个空间中，然后清空整个新生代空间。Full GC主要回收老年代中的对象，以及在新生代中晋升到老年代的对象。</li><li>垃圾收集时间不同：Minor GC的触发频率比较高，一般来说时间很短，一般不会造成系统停顿。Full GC的出发频率比较低，一般需要一定的时间来完成垃圾回收操作，可能会导致系统暂停或停顿。</li><li>内存回收效率不同：Minor GC只需要回收新生代对象，内存回收效率比较高，而Full GC需要回收整个堆空间中的对象，内存回收率比较低。</li></ol><p>综上所述，Minor GC和Full GC是两种不同的垃圾收集器，他们的触发时机、回收对象、垃圾收集时间和内存回收率都有所不同。</p></blockquote><h4 id="6、如何判断对象是否死亡？（两种方法）"><a href="#6、如何判断对象是否死亡？（两种方法）" class="headerlink" title="6、如何判断对象是否死亡？（两种方法）"></a>6、如何判断对象是否死亡？（两种方法）</h4><blockquote><ol><li>引用计数法：引用计数法是一种常见的判断对象是否死亡的方法。在这种方法中，每个对象都有一个引用计数器，用于统计当前有多少个对象引用该对象。当对象的引用计数器为0时，说明该对象不再被引用，可以被垃圾回收器回收。但是这种方法存在一个问题，就是很难解决循环引用的问题，即A对象引用B对象，而B对象又引用A对象，导致引用计数器都不为0，从而导致内存泄漏。</li><li>可达性分析法：可达性分析法是Java中常用的判断对象是否死亡的方法。在这种方法中，通过一系列称为”GC Roots”的根对象作为起点，从这些根对象开始向下搜索，搜索过程中遇到的对象都被标记为存活对象，未搜索到的对象则被标记为可回收对象。这种方法的优点是可以有效解决循环引用的问题，同时也可以准确地判断对象是否死亡。Java中的垃圾回收器就是基于可达性分析法实现的。</li></ol></blockquote><h4 id="7、如何判断一个常量是否时废弃常量？"><a href="#7、如何判断一个常量是否时废弃常量？" class="headerlink" title="7、如何判断一个常量是否时废弃常量？"></a>7、如何判断一个常量是否时废弃常量？</h4><blockquote><p>在Java中，如果一个常量不再被任何程序引用，那么就可以被认为是废弃常量，可以被垃圾回收器回收。判断常量是否废弃常量，可以使用工具类jmap和jhat。</p><p>具体步骤如下：</p><ol><li>使用jmap命令生成Java进程的内存转储文件：jmap -dump:live,format&#x3D;b,file&#x3D;heap.bin <pid></li><li>使用jhat命令将内存转储文件转换成可视化的HTML页面：jhat heap.bin</li><li>打开生成的HTML页面，在左侧导航栏中选择”Sites”，然后在”Show unreachable objects”中选择”true”，即可查看所有废弃对象。</li><li>在页面中选择”Constant Pools”，可以查看所有的常量池，包括String常量池、Class常量池等。废弃常量往往会存在于常量池中。</li><li>可以通过查看常量池中的引用数来判断常量是否废弃。如果一个常量没有被任何对象引用，那么它的引用数应该为0，可以通过查看常量池中每个常量的引用数来确定是否废弃常量。</li></ol><p>需要注意的是，判断常量是否废弃常量需要使用jmap和jhat等工具类，这些工具类仅在开发和测试环境下使用，不应在生产环境中使用。</p></blockquote><h4 id="8、如何判断一个类是无用的类？"><a href="#8、如何判断一个类是无用的类？" class="headerlink" title="8、如何判断一个类是无用的类？"></a>8、如何判断一个类是无用的类？</h4><blockquote><ol><li>类没有被加载：如果一个类还没有被加载到内存，那么他肯定是无用的类。</li><li>类的所有实例都已被回收：如果一个类的所有实例都已经被垃圾回收器回收，那么该类也可以认为是无用的类、</li><li>类的Class对象没有被引用：在Java中，每个类都有一个对应的Class对象，如果一个类的Class对象没有被其他对象引用，那么该类也可以被认为是无用的类。</li><li>类的实例被引用，但是该类没有任何方法被调用：如果一个类的实例被引用，但是该类没有任何方法被调用，那么该类也可以认为是无用的类。</li></ol><p>在实际应用中，我们可以使用一些工具来分析应用程序中的类的引用关系，从而找出无用的类。例如，可以使用JDK自带的工具jmap、jhat、jstat等，或者使用第三方工具如VisualVM等进行分析。</p></blockquote><h4 id="9、垃圾收集有哪些算法，各自的特点？"><a href="#9、垃圾收集有哪些算法，各自的特点？" class="headerlink" title="9、垃圾收集有哪些算法，各自的特点？"></a>9、垃圾收集有哪些算法，各自的特点？</h4><blockquote><ol><li>标记-清除算法（Mark-Sweep）：标记-清除算法是最早的垃圾回收算法之一，它分为标记和清除两个阶段。标记阶段会遍历所有的对象，并将被引用的对象标记为“存活”，未被标记的对象就是“垃圾”。清除阶段会将所有未被标记的对象回收。该算法的优点是简单易实现，但缺点是容易产生内存碎片。</li><li>复制算法（Copying）：复制算法将可用内存分为两个相等的区域，每次只使用其中一个区域，当这个区域用完之后，将还存活的对象复制到另一个区域中，然后将原来的区域全部清空。该算法的优点是不会产生内存碎片，但缺点是只能利用一半的内存空间。</li><li>标记-整理算法（Mark-Compact）：标记-整理算法也是一种标记式的垃圾回收算法，它在标记阶段与标记-清除算法类似，但在清除阶段不是直接回收未标记的对象，而是将所有存活的对象向一端移动，然后将另一端的空间全部回收。该算法的优点是不会产生内存碎片，但缺点是效率较低。</li><li>分代收集算法（Generational）：分代收集算法是现代垃圾回收算法中最常用的算法之一，它根据对象的存活周期将内存分为不同的代，通常将新生代分为Eden空间和两个Survivor空间，老年代则单独一块。一般情况下，新生代中的对象的存活时间较短，老年代中的对象的存活时间较长。分代收集算法可以针对不同代采用不同的垃圾回收算法，以提高回收效率和降低停顿时间。</li></ol><p>不同的垃圾回收算法有着不同的特点和适用场景，应根据实际应用场景选择合适的垃圾回收算法。例如，对于大型的服务器应用程序，可以使用CMS收集器或G1收集器等具有低停顿时间的算法；对于小型的客户端应用程序，可以使用Serial或Parallel收集器等具有高吞吐量的算法。</p></blockquote><h4 id="10、HotSpot为什么要分新生代和老年代？"><a href="#10、HotSpot为什么要分新生代和老年代？" class="headerlink" title="10、HotSpot为什么要分新生代和老年代？"></a>10、HotSpot为什么要分新生代和老年代？</h4><blockquote><ol><li>对象的生命周期不同</li><li>不同的垃圾回收算法适用于不同的区域</li></ol></blockquote><h4 id="11、常见的垃圾回收器有哪些？"><a href="#11、常见的垃圾回收器有哪些？" class="headerlink" title="11、常见的垃圾回收器有哪些？"></a>11、常见的垃圾回收器有哪些？</h4><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202302011419939.png" alt="垃圾回收器"></p><blockquote><ol><li>Serial收集器：Serial收集器是最早的Java垃圾回收器，它是单线程的，只能使用单个CPU进行垃圾回收。Serial收集器适用于小型应用程序或客户端应用程序，它的优点是简单、高效、内存占用小，但缺点是垃圾回收过程可能会导致应用程序暂停。</li><li>Parallel收集器：Parallel收集器是Serial收集器的并行版本，它使用多线程进行垃圾回收，可以充分利用多核CPU的优势，提高垃圾回收效率。Parallel收集器适用于对吞吐量要求高的应用程序，如数据处理等，但它同样也可能导致应用程序暂停。</li><li>CMS收集器：CMS（Concurrent Mark Sweep）收集器是一种以低停顿时间为目标的垃圾回收器，它使用多线程并发收集，可以在应用程序运行时进行垃圾回收。CMS收集器适用于对应用程序停顿时间要求高的场景，如Web应用程序等。但是CMS收集器也有一些缺点，如容易产生碎片、垃圾回收效率相对较低等。三色标记算法</li><li>G1收集器：G1（Garbage First）收集器是一种面向服务端的垃圾回收器，它将堆内存分割成多个小块，每次只回收其中的一部分，可以有效避免全局垃圾回收导致的长时间停顿。G1收集器适用于对停顿时间和吞吐量都有要求的场景，如互联网服务、金融交易系统等。</li></ol></blockquote><h4 id="12、类加载过程"><a href="#12、类加载过程" class="headerlink" title="12、类加载过程"></a>12、类加载过程</h4><blockquote><p>在Java中，类加载是指将Java类的字节码加载到Java虚拟机中，并转换为Java对象的过程。Java类加载过程一般可以分为以下三个阶段：</p><ol><li><p>加载阶段：在这个阶段，Java虚拟机通过类加载器将类的字节码从磁盘或网络中加载到内存中，并在内存中创建一个对应的Class对象。这个Class对象包含了该类的完整信息，如类的方法、属性和父类等信息。</p></li><li><p>链接阶段：在这个阶段，Java虚拟机对类进行链接。具体来说，链接阶段包括以下三个步骤：</p><p>1）验证：对字节码进行验证，以确保字节码符合Java虚拟机规范，不会危害虚拟机自身的安全。</p><p>2）准备：为类的静态变量分配内存并初始化为默认值，如int类型的变量初始化为0，String类型的变量初始化为null等。</p><p>3）解析：将符号引用转换为直接引用，即将类、方法、字段等符号引用解析为在内存中的直接引用。</p></li><li><p>初始化阶段：在这个阶段，Java虚拟机执行类的静态初始化代码块。静态初始化代码块可以包含静态变量的赋值、静态代码块的执行等操作。当一个类被初始化时，它的父类也会被初始化，如果父类还有父类，则依次递归执行。</p></li></ol><p>值得注意的是，类的加载、链接和初始化阶段并非完全独立，它们之间可能存在依赖关系。例如，在解析阶段需要访问类的父类或接口，因此在加载和链接阶段也需要加载和链接父类或接口。</p><p>综上所述，Java类加载过程包括加载、链接和初始化三个阶段，这三个阶段之间可能存在依赖关系，它们共同完成将Java类的字节码加载到Java虚拟机中的过程。</p></blockquote><h3 id="六、Spring"><a href="#六、Spring" class="headerlink" title="六、Spring"></a>六、Spring</h3><h4 id="1、什么是Spring框架？"><a href="#1、什么是Spring框架？" class="headerlink" title="1、什么是Spring框架？"></a>1、什么是Spring框架？</h4><blockquote><p>Spring框架是一个开源的Java应用框架，它提供了一个全面的编程和配置模型，用于构建企业级应用程序和服务。Spring框架的核心特性包括：</p><ol><li>依赖注入（Dependency Injection）：通过IOC容器管理组件之间的依赖关系，将应用程序的组件解耦并进行松散耦合设计。</li><li>控制反转（IOC）：通过IOC容器管理组件之间的依赖关系，将应用程序的组件解耦并进行松散耦合设计。</li><li>面向切面编程（Aspect-Oriented Programming）：提供AOP框架，通过切面（Aspect）和通知（Advice）将横切关注点（Cross-cutting Concerns）从核心业务逻辑中分离出来，提高代码的可重用性和可维护性。</li><li>数据访问（Data Access）：提供ORM框架，支持多种数据源和持久化技术，如JDBC、Hibernate、MyBatis等，简化数据访问层的开发。</li><li>Web应用（Web Application）：提供Web MVC框架，支持RESTful架构、模板引擎、表单处理、文件上传等，简化Web应用的开发。</li><li>消息传递（Messaging）：提供消息中间件（Message Middleware）的支持，如JMS、AMQP等，使得应用程序之间可以使用异步方式进行通信。</li><li>测试（Testing）：提供JUnit、Mockito等测试框架的支持，使得应用程序的单元测试、集成测试等变得更加简单和高效。</li></ol><p>Spring框架的目标是提高Java应用程序的开发效率和质量，同时降低应用程序的复杂性和维护成本。它在业界得到了广泛的应用和认可，成为了Java应用开发的事实标准之一。</p></blockquote><h4 id="2、列举一些重要的Spring模块？"><a href="#2、列举一些重要的Spring模块？" class="headerlink" title="2、列举一些重要的Spring模块？"></a>2、列举一些重要的Spring模块？</h4><blockquote><p>Spring是一个非常庞大的框架，包含了很多不同的模块和组件，下面列举一些比较重要的Spring模块：</p><ol><li>Spring Core：Spring核心模块，提供了IoC容器的基本实现和管理机制，包括BeanFactory和ApplicationContext两个核心接口。</li><li>Spring AOP：基于面向切面编程（AOP）的模块，提供了AOP框架，支持切面、通知、切点等概念，可以实现事务管理、日志记录、安全控制等功能。</li><li>Spring ORM：提供了对对象关系映射（ORM）框架的支持，包括Hibernate、JPA等。</li><li>Spring JDBC：提供了对JDBC的支持，包括简化JDBC操作、异常处理、事务管理等功能。</li><li>Spring Web：提供了基于Servlet的Web开发框架，包括MVC框架、Websockets、REST支持等。</li><li>Spring Integration：提供了企业应用集成（EAI）的支持，包括消息传递、文件传输、远程调用等功能。</li><li>Spring Batch：提供了批处理的支持，包括任务调度、处理流程、监控等功能。</li><li>Spring Security：提供了安全框架的支持，包括身份认证、授权、访问控制等功能。</li></ol><p>除了以上列举的模块外，Spring还包括了很多其他的模块，如Spring Mobile、Spring HATEOAS、Spring Data等。这些模块都为Spring框架提供了丰富的功能和特性，使得Spring框架在不同的应用场景中都具有很高的适用性和灵活性。</p></blockquote><h4 id="3、-RestController和-Controller的区别？"><a href="#3、-RestController和-Controller的区别？" class="headerlink" title="3、@RestController和@Controller的区别？"></a>3、@RestController和@Controller的区别？</h4><blockquote><p><code>@RestController</code> 和 <code>@Controller</code> 是 Spring 框架中用来声明控制器的注解。它们的主要区别在于它们的作用和返回结果类型。</p><p>@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。</p><p><code>@Controller</code> 注解通常用于传统的 Web 应用程序中，它表示这是一个控制器类，它可以处理 HTTP 请求和响应。通常情况下，它处理完请求后需要返回一个视图，比如一个 HTML 页面或者一个 JSP 页面。因此，<code>@Controller</code> 注解的方法通常返回一个 <code>String</code> 类型，这个字符串是视图名称或者视图的完整路径。</p><p>相反，<code>@RestController</code> 注解通常用于编写 RESTful 风格的 Web 服务或者 API 接口，它表示这是一个控制器类，它可以处理 HTTP 请求和响应。但是，它的返回结果类型不是视图，而是数据。<code>@RestController</code> 注解的方法通常返回一个 Java 对象，这个对象会被自动序列化为 JSON 或者 XML 格式的数据，并返回给客户端。</p><p>因此，<code>@RestController</code> 注解通常比 <code>@Controller</code> 更为简单和方便，因为它可以直接返回数据而不需要进行视图解析。同时，使用 <code>@RestController</code> 可以更好地实现前后端分离，将前端和后端逻辑分开，提高了代码的可维护性和可读性。</p></blockquote><h4 id="4、讲一下Spring-IOC和AOP"><a href="#4、讲一下Spring-IOC和AOP" class="headerlink" title="4、讲一下Spring IOC和AOP"></a>4、讲一下Spring IOC和AOP</h4><blockquote><p>Spring是一个Java开发的框架，提供了很多特性，其中最核心的特性之一是IOC（Inversion of Control）和AOP（Aspect Oriented Programming）。</p><p>IOC（控制反转）是指将控制权从应用程序代码中解耦出来，让容器负责管理对象之间的依赖关系。在Spring中，通过容器管理Bean对象，可以在需要时将它们注入到其他对象中。这样，应用程序就可以专注于实现业务逻辑，而不必关心对象之间的依赖关系。Spring提供了多种方式实现IOC，包括XML配置、Java注解、Java配置等。</p><p>AOP（面向切面编程）是指将跨越多个方法或对象的功能（如日志记录、性能监控等）封装起来，从而简化代码，提高代码的重用性和可维护性。在Spring中，通过AOP可以在不修改原有代码的情况下，实现一些横切关注点（crosscutting concern），如事务管理、异常处理、缓存等。Spring的AOP实现基于代理模式，通过动态代理来实现。</p><p>Spring的IOC和AOP是Spring框架的两个核心特性，它们可以提高应用程序的模块化和可重用性，使代码更加易于维护和扩展。</p></blockquote><h4 id="5、Spring中的bean的作用域有哪些？"><a href="#5、Spring中的bean的作用域有哪些？" class="headerlink" title="5、Spring中的bean的作用域有哪些？"></a>5、Spring中的bean的作用域有哪些？</h4><blockquote><p>在Spring中，Bean的作用域是指Bean对象在Spring容器中的生命周期和可见范围。Spring支持以下5种Bean作用域：</p><ol><li>Singleton：单例模式，一个Spring容器中只有一个Bean实例，默认作用域。通过Spring容器获取同一个Bean对象，每次都是返回同一个实例对象。</li><li>Prototype：原型模式，每次从Spring容器中获取Bean对象时，都会创建一个新的实例对象。即每次获取Bean时，都会创建一个新的Bean实例。</li><li>Request：每个HTTP请求都会创建一个新的Bean实例，在请求处理完成后，Bean实例就会被销毁。仅在Web应用程序中使用。</li><li>Session：与Request作用域类似，但作用于整个会话期间。在用户会话结束时，Bean实例被销毁。仅在Web应用程序中使用。</li><li>GlobalSession：在Portlet环境下使用，每个用户会话中只有一个Bean实例，作用于整个应用程序。</li></ol><p>以上这些作用域是通过Spring的BeanFactory和ApplicationContext来实现的。可以在XML配置文件或Java代码中通过“scope”属性指定Bean的作用域，例如：</p></blockquote><h4 id="6、Spring中的单例bean的线程安全问题？"><a href="#6、Spring中的单例bean的线程安全问题？" class="headerlink" title="6、Spring中的单例bean的线程安全问题？"></a>6、Spring中的单例bean的线程安全问题？</h4><blockquote><p>在Spring中，单例（Singleton）作用域的Bean是默认的作用域，即在整个应用程序中只有一个实例。因此，在使用单例Bean时需要考虑线程安全的问题。</p><p>如果单例Bean是无状态的（即不存储任何状态信息），那么它是线程安全的，可以同时在多个线程中使用。但是，如果单例Bean是有状态的（即存储了状态信息），那么在多线程环境下可能会存在线程安全问题，需要采取一些措施保证线程安全。</p><p>下面介绍几种保证单例Bean线程安全的方法：</p><ol><li>避免共享状态：将单例Bean设计为无状态的，避免存储共享状态信息，这样就可以避免线程安全问题。</li><li>同步访问：使用synchronized关键字或者Lock对象等机制，在访问有状态的单例Bean时进行同步，保证同一时刻只有一个线程访问。</li><li>使用ThreadLocal：将有状态的单例Bean的状态信息存储在ThreadLocal对象中，这样每个线程都有自己独立的状态信息，从而避免线程安全问题。</li><li>使用代理对象：使用代理对象来访问有状态的单例Bean，代理对象控制对单例Bean的访问，从而保证线程安全。</li></ol><p>总之，Spring中的单例Bean可能存在线程安全问题，需要在实现时考虑线程安全问题，使用适当的线程安全技术来保证单例Bean的线程安全性。</p></blockquote><h4 id="7、-Component和-Bean的区别是什么？"><a href="#7、-Component和-Bean的区别是什么？" class="headerlink" title="7、@Component和@Bean的区别是什么？"></a>7、@Component和@Bean的区别是什么？</h4><blockquote><p>作用对象不同：</p><ol><li><strong>@Component</strong>注解作用于类</li><li><strong>@Bean</strong>作用于方法</li></ol><p>使用方法不同：</p><ol><li><strong>@Component</strong>注解直接标注在类声明上即可</li><li><strong>@Bean</strong>需要在配置类中使用，即类上需要加上@Configuration注解，然后在配置类中使用一个方法定义bean是如何创建的</li></ol><p>实现不同：</p><ol><li><strong>@Component注解通常是通过类路径扫描来自动侦测以及自动装配到spring容器中（使用</strong>Component注解定义要扫描的路径<strong>）</strong></li><li><strong>@Bean注解通常是在标有</strong>@Configuration注解的方法中定义产生的这个bean，默认情况下，它将使用方法的名称作为bean的id</li></ol><p>灵活性不同：</p><ol><li>@Bean注解比@Component注解灵活，我们可以按需注册需要的bean，很多场景我们只能通过@Bean来注册bean，比如引入第三方库中农的类需要装配到spring容器中。</li></ol></blockquote><h4 id="8、将一个类声明为Spring的bean的注解有哪些？"><a href="#8、将一个类声明为Spring的bean的注解有哪些？" class="headerlink" title="8、将一个类声明为Spring的bean的注解有哪些？"></a>8、将一个类声明为Spring的bean的注解有哪些？</h4><blockquote><p>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired注解自动装配的 bean 的类,采用以下注解可实现：</p><p>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用</p><p>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</p><p>@Service :对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</p><p>@Controller : 对应 Spring MVC控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p></blockquote><h4 id="9、Spring中bean的生命周期？"><a href="#9、Spring中bean的生命周期？" class="headerlink" title="9、Spring中bean的生命周期？"></a>9、Spring中bean的生命周期？</h4><blockquote><p>大致分为以下几个阶段：</p><ol><li>实例化 Bean</li><li>设置 Bean 属性</li><li>调用 Bean 的初始化方法</li><li>Bean 可以使用</li><li>当容器关闭时，调用 Bean 的销毁方法</li></ol></blockquote><h4 id="10、Spring-MVC工作原理？"><a href="#10、Spring-MVC工作原理？" class="headerlink" title="10、Spring MVC工作原理？"></a>10、Spring MVC工作原理？</h4><blockquote><p>Spring MVC是Spring框架中的一个模块，它是基于MVC（Model-View-Controller）设计模式的Web框架，用于处理Web应用程序的请求和响应。</p><p>Spring MVC框架的工作流程如下：</p><ol><li>首先，客户端发送请求到DispatcherServlet。</li><li>DispatcherServlet是Spring MVC框架的核心控制器，他接收所有的客户端请求，并负责将请求发送给对应的处理器。</li><li>HandlerMapping是Spring MVC框架的一个组件，它负责将请求映射到对应的处理器（即Controller）。</li><li>一旦找到了合适的Controller，DispatcherServlet就会将请求发送给它。</li><li>Controller接受请求，并调用相应的业务逻辑进行处理，并返回一个Model And View对象。</li><li>Model And View是一个包含了视图名称和模型数据的对象。视图名称用于标识视图（即JSP页面），而模型数据则是Controller处理请求后产生的数据。</li><li>ViewResolver是Spring MVC框架的另一个组件，他将视图名称解析成一个具体的视图（即JSP页面）。</li><li>一旦找到了合适的试图，DispatcherServlet就会将模型数据传递给视图进行渲染。</li><li>最后，DispatcherServlet将渲染后的视图返回给客户端，完成整个请求处理过程。</li></ol><p>总之，Spring MVC框架通过DispatcherServlet、HandlerMapping、Controller、ModelAndView、ViewResolver等组件协同工作，将客户端请求转化为相应的响应结果，并将结果返回给客户端。</p></blockquote><h4 id="11、Spring框架中用到了哪些设计模式？"><a href="#11、Spring框架中用到了哪些设计模式？" class="headerlink" title="11、Spring框架中用到了哪些设计模式？"></a>11、Spring框架中用到了哪些设计模式？</h4><blockquote><p>Spring框架是一个庞大的框架，其中涉及到了多种设计模式。以下是一些常见的设计模式在Spring框架中的应用：</p><ol><li>依赖注入（DI）&#x2F; 控制反转（IOC）：这是Spring框架最基本的设计模式，用于将对象之间的依赖关系从编码时确定转换成配置时确定，从而减少代码之间的耦合。Spring框架通过依赖注入将对象之间的依赖关系转交给框架进行管理。</li><li>AOP（面向切面编程）：AOP是一种通过在程序执行期间动态地将代码切入到类的指定方法或特定点上的编程方式，它可以帮助程序员将应用程序中的各个方面解耦并提供横切关注点的重用性。在Spring框架中，AOP可以用于事务管理、安全检查等方面。</li><li>模板方法模式：Spring框架提供了一些模板类，比如JdbcTemplate和HibernateTemplate等，这些模板类将一些通用的操作封装在模板方法中，以减少代码的冗余度和提高代码的可读性。</li><li>工厂模式：Spring框架提供了很多工厂类来创建对象，比如BeanFactory和ApplicationContext等，这些工厂类负责创建和管理对象，以解耦应用程序的配置和实现。</li><li>单例模式：Spring框架中的bean默认都是单例的，也就是说，在应用程序的整个生命周期中，每个bean只有一个实例，这符合单例模式的设计思想。</li><li>观察者模式：Spring框架中的事件机制就是一个典型的观察者模式的应用，当某个事件发生时，观察者对象将会收到通知并作出相应的反应。</li></ol></blockquote><h4 id="12、Spring事务中的隔离级别有哪几种？"><a href="#12、Spring事务中的隔离级别有哪几种？" class="headerlink" title="12、Spring事务中的隔离级别有哪几种？"></a>12、Spring事务中的隔离级别有哪几种？</h4><blockquote><p>Sping 中的事务隔离级别有 5 种，它们分别是：</p><ol><li>DEFAULT： Spring 中默认的事务隔离级别 ，以连接的数据库的事务隔离级别为准；</li><li>READ_UNCOMMITTED：读未提交，也叫未提交读，该隔离级别的事务可以看到其他事务中未提交的数据。该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读；</li><li>READ_COMMITTED：读已提交，也叫提交读，该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读；</li><li>REPEATABLE_READ：可重复读，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）；</li><li>SERIALIZABLE：串行化，最高的事务隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。</li></ol><p>所以， 相比于 MySQL 的事务隔离级别，Spring 中多了一种 DEFAULT 的事务隔离级别 。</p></blockquote><h4 id="13、Spring事务中有哪几种事务的传播行为？"><a href="#13、Spring事务中有哪几种事务的传播行为？" class="headerlink" title="13、Spring事务中有哪几种事务的传播行为？"></a>13、Spring事务中有哪几种事务的传播行为？</h4><blockquote><ol><li>REQUIRED：如果当前没有事务，则新建一个事务；如果已经存在事务，则加入该事务。适用于大多数业务场景，保证了业务操作的完整性和一致性。</li><li>SUPPORTS：如果当前存在事务，则加入该事务；如果不存在事务，则以非事务方式执行。适用于读取操作，避免不必要的事务开销。</li><li>MANDATORY：必须在已存在的事务中执行，否则抛出异常。适用于要求业务操作必须在事务中进行的场景。</li><li>REQUIRES_NEW：每次都会新建一个事务，如果当前存在事务，则将当前事务挂起，并新建一个事务进行操作。适用于某些业务操作需要独立的事务环境，不受外部事务的影响。</li><li>NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则将其挂起。适用于一些无需事务支持的操作，如清空日志、统计数据等。</li><li>NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。适用于一些绝对不需要事务支持的操作。</li><li>NESTED：如果存在事务，则在该事务中创建一个新的嵌套事务，如果不存在事务，则新建一个事务。内部事务可以独立提交或回滚，不影响外部事务的提交或回滚。适用于某些需要进行子业务操作的场景。</li></ol><p>下面是每个传播行为的具体案例：</p><ol><li>REQUIRED：一个银行转账操作，转账过程需要对转出账户和转入账户进行更新，这两个操作需要在同一个事务中执行。</li><li>SUPPORTS：查询用户信息，不需要对数据库进行更新操作，因此不需要使用事务。</li><li>MANDATORY：对于更新用户信息这种必须使用事务的操作，如果在没有事务的情况下执行，就需要抛出异常。</li><li>REQUIRES_NEW：某个业务需要对一批数据进行删除和新增操作，但是删除操作需要在事务中进行，新增操作不需要，可以使用REQUIRES_NEW来新建一个事务进行删除操作。</li><li>NOT_SUPPORTED：清空日志的操作可以使用NOT_SUPPORTED，因为它不需要事务的支持。</li><li>NEVER：删除某个数据，如果在事务中执行，可能会引起其他数据的不一致，因此可以使用NEVER来禁止事务。</li><li>NESTED：某个订单涉及多个子订单，如果某个子订单操作失败，可以回滚该子订单的操作，而不会影响其他子订单或者主订单的状态，这时可以使用NESTED。</li></ol></blockquote><h4 id="14、-Transactionl-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#14、-Transactionl-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="14、@Transactionl(rollbackFor &#x3D; Exception.class)注解了解吗？"></a>14、@Transactionl(rollbackFor &#x3D; Exception.class)注解了解吗？</h4><blockquote><p>在项目中，@Transactional(rollbackFor&#x3D;Exception.class)，如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p><p>在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor&#x3D;Exception.class,可以让事物在遇到非运行时异常时也回滚</p></blockquote><h3 id="七、Redis"><a href="#七、Redis" class="headerlink" title="七、Redis"></a>七、Redis</h3><h4 id="1、Redis为什么这么快？"><a href="#1、Redis为什么这么快？" class="headerlink" title="1、Redis为什么这么快？"></a>1、Redis为什么这么快？</h4><blockquote><p>Redis内部做了非常多的性能优化，比较重要的主要有以下三点：</p><ul><li>Redis基于内存，内存的访问速度是磁盘的上千倍；</li><li>Redis基于Reactor模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和IO多路复用；</li><li>Redis内置了多种优化过后的数据结构实现，性能非常高。</li></ul></blockquote><h4 id="2、说一下Redis和Memcached的区别和共同点"><a href="#2、说一下Redis和Memcached的区别和共同点" class="headerlink" title="2、说一下Redis和Memcached的区别和共同点"></a>2、说一下Redis和Memcached的区别和共同点</h4><blockquote><p>现在一般都是用Redis来实现缓存。</p><p>共同点：</p><ul><li>都是基于内存的数据库，一般都用来当缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ul><p>区别：</p><ul><li><p><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</p><p><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></p><p><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</p><p><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></p><p><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></p><p><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</p><p><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></p><p><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></p></li></ul></blockquote><h4 id="3、为什么要用Redis-x2F-为什么要用缓存？"><a href="#3、为什么要用Redis-x2F-为什么要用缓存？" class="headerlink" title="3、为什么要用Redis&#x2F;为什么要用缓存？"></a>3、为什么要用Redis&#x2F;为什么要用缓存？</h4><blockquote><p>主要从“高性能”和“高并发”这两个点来进行讲解。</p><p><strong>高性能</strong>：</p><ul><li>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢的，因为是从硬盘中读取的。但是，如果用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</li></ul><p><strong>高并发</strong>：</p><ul><li><p>一般像MySQL这类的数据库的QPS大概都在1w左右（4核8g），但是使用Redis缓存之后很容易达到10w+，甚至最高能达到30w+（就单机Redis的情况，Redis集群的话会更高）。</p><p><code>QPS（Query Per Second）</code>：服务器每秒可以执行的查询次数。</p></li></ul></blockquote><h4 id="4、Redis处理做缓存，还能做什么？"><a href="#4、Redis处理做缓存，还能做什么？" class="headerlink" title="4、Redis处理做缓存，还能做什么？"></a>4、Redis处理做缓存，还能做什么？</h4><blockquote><ul><li>分布式锁：通过Redis来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于Redisson来实现分布式锁。</li><li>限流：一般是通过Redis + Lua脚本的方式来实现限流的。</li><li>消息队列：Redis自带的list数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li>复杂业务场景：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li></ul></blockquote><h4 id="5、Redis常用的数据结构有哪些？"><a href="#5、Redis常用的数据结构有哪些？" class="headerlink" title="5、Redis常用的数据结构有哪些？"></a>5、Redis常用的数据结构有哪些？</h4><blockquote><ul><li>5种基础数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li>3种特殊的数据结构：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li></ul></blockquote><h4 id="6、Redis内存淘汰机制"><a href="#6、Redis内存淘汰机制" class="headerlink" title="6、Redis内存淘汰机制"></a>6、Redis内存淘汰机制</h4><blockquote><p>首先先来讲一讲过期数据的删除策略吧。</p><ul><li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ul><p>定期删除对内存更加友好，惰性删除对CPU更加友好。而Redis是采用的<code>定期删除 + 惰性/懒汉式删除</code>。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>解决这个问题就要讲到<strong>Redis内存淘汰机制</strong>了。</p><p><code>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</code></p><p>Redis提供了6种数据淘汰策略：</p><ul><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ul></blockquote><h4 id="7、什么是RDB持久化"><a href="#7、什么是RDB持久化" class="headerlink" title="7、什么是RDB持久化"></a>7、什么是RDB持久化</h4><blockquote><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save <span class="token number">900</span> <span class="token number">1</span>           <span class="token comment">#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span>save <span class="token number">300</span> <span class="token number">10</span>          <span class="token comment">#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span>save <span class="token number">60</span> <span class="token number">10000</span>        <span class="token comment">#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>save</code> : 主线程执行，会阻塞主线程；</li><li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li></ul></blockquote><h4 id="8、什么是AOF持久化？"><a href="#8、什么是AOF持久化？" class="headerlink" title="8、什么是AOF持久化？"></a>8、什么是AOF持久化？</h4><blockquote><p>AOP持久化：将Redis执行的每条命令记录在一个日志文件中，以便在Redis重启时重新执行这些命令。可以选择每秒钟同步日志文件到磁盘中，或者在Redis退出时同步。该方式的缺点是会导致较慢的性能。</p></blockquote><h4 id="9、Redis的集群模式有哪些？"><a href="#9、Redis的集群模式有哪些？" class="headerlink" title="9、Redis的集群模式有哪些？"></a>9、Redis的集群模式有哪些？</h4><blockquote><ul><li>主从复制模式：一个主节点可以拥有多个从节点 ，主节点将数据同步到从节点上。从节点可以处理读请求，主节点可以处理写请求。</li><li>Sentinel模式：是Redis的一个分布式系统，用于监控Redis主节点的状态。当主节点宕机时，Sentinel会选举一个新的主节点，并通知所有的客户端切换到新的主节点上。</li><li>Redis Cluster模式：时Redis的分布式集群模式。它将数据分片存储在多个节点上，并使用复制机制提高可用性和容错性。</li></ul></blockquote><h4 id="10、Redis如何保证数据的一致性？"><a href="#10、Redis如何保证数据的一致性？" class="headerlink" title="10、Redis如何保证数据的一致性？"></a>10、Redis如何保证数据的一致性？</h4><blockquote><p>Redis采用单线程模式处理命令需求，因此不存在多线程并发问题。Redis通过使用原子操作和基于事务的命令来解决并发问题。Redis还提供了乐观锁和悲观锁等机制，可以根据实际情况选择合适的锁机制。</p></blockquote><h4 id="11、Redis的性能瓶颈是什么？"><a href="#11、Redis的性能瓶颈是什么？" class="headerlink" title="11、Redis的性能瓶颈是什么？"></a>11、Redis的性能瓶颈是什么？</h4><blockquote><ul><li>网络带宽限制：在高并发情况下，网络带宽可能成为Redis的性能瓶颈。</li><li>CPU和内存资源限制：当Redis存储的数据量非常大时，CPU和内存可能成为性能瓶颈。</li><li>持久化性能限制：持久化操作可能会影响Redis的性能。</li><li>键值的存储和查询效率：在某些情况下，Redis的键值存储和查询效率可能会成为性能瓶颈。</li></ul></blockquote><h4 id="12、Redis如何保证高可用性？"><a href="#12、Redis如何保证高可用性？" class="headerlink" title="12、Redis如何保证高可用性？"></a>12、Redis如何保证高可用性？</h4><blockquote><p>Redis通过主从复制和Sentinel模式提供高可用性支持。在主从复制中，Redis可以将数据同步到多个从节点上，当主节点宕机时，从节点可以接管主节点的工作，从而保证Redis的可用性。在Sentinel模式中，Sentinel可以监控Redis主节点的状态，当主节点宕机时，Sentinel会选举一个新的主节点，并通知所有客户端切换到新的主节点上。</p></blockquote><h4 id="13、Redis的缓存穿透、缓存击穿和缓存雪崩问题如何解决？"><a href="#13、Redis的缓存穿透、缓存击穿和缓存雪崩问题如何解决？" class="headerlink" title="13、Redis的缓存穿透、缓存击穿和缓存雪崩问题如何解决？"></a>13、Redis的缓存穿透、缓存击穿和缓存雪崩问题如何解决？</h4><blockquote><ul><li><p>缓存穿透</p><p>缓存穿透是指请求一个不存在的数据，由于缓存中没有这个数据，每次请求都会穿透到数据库中，造成数据库的压力 。</p><ul><li>可以使用布隆过滤器，对请求的key进行预处理过滤掉不存在的key。</li><li>在缓存中假如空对象或默认值，使缓存中始终存在该数据的建，减少缓存穿透的概率。</li></ul></li><li><p>缓存击穿</p><p>缓存击穿是指某个热点数据在缓存中过期或被删除后，大量请求同时访问该数据，导致请求直接穿透到数据库，压垮数据库，引起系统崩溃。</p><ul><li>设置热点数据的过期时间，采用随机时间的方式，避免缓存同时失效。</li><li>采用分布式锁，只允许一个线程访问数据库，其他线程等待该线程从数据库中加载数据到缓存中后再访问。</li><li>对热点数据不设置过期时间，或者使用永久缓存等方式，保证数据一直存在于缓存中，避免缓存失效。</li></ul></li><li><p>缓存雪崩</p><p>缓存雪崩是指缓存中大量的数据在同一时间过期或失效，导致大量请求直接访问数据库，引起数据库的宕机或系统崩溃。</p><ul><li>设置缓存失效时间，采用分布式随机时间的方式，避免大量的缓存同时失效。</li><li>采用多级缓存架构，例如增加本地缓存或CDN缓存，减轻单一缓存的压力。</li><li>在缓存中增加限流、熔断等机制，限制请求的访问量，避免突发的请求了过大。</li></ul></li></ul></blockquote><h4 id="14、Redis如何处理高并发请求？"><a href="#14、Redis如何处理高并发请求？" class="headerlink" title="14、Redis如何处理高并发请求？"></a>14、Redis如何处理高并发请求？</h4><blockquote><ul><li>增加Redis实例：通过增加Redis集群，可以实现更加高效的缓存读写，</li><li>并提高系统的并发处理能力。</li><li>使用Redis集群：通过Redis集群，可以将缓存数据分散到不同的Redis节点上，从而实现更好的并发处理能力。</li><li>使用Redis缓存预热：在系统启动时，将热点数据提前加载到Redis缓存中，可以避免大量请求同时访问缓存造成的性能问题。</li><li>使用Redis Pipeline：Redis Pipeline可以在一次网络通信中同时执行多个命令，从而提高缓存读写的效率和响应速度。</li><li>使用Redis分布式锁：当多个请求同时访问同一资源时，可以使用Redis分布式锁实现对资源的加锁，从而避免并发冲突问题。</li></ul></blockquote><h4 id="15、Redis中的事务是什么？"><a href="#15、Redis中的事务是什么？" class="headerlink" title="15、Redis中的事务是什么？"></a>15、Redis中的事务是什么？</h4><blockquote><p>Redis中的事务是一组命令的集合，可以作为一个单独的操作执行。在Redis事务中，可以将多个命令组合成一个原子操作，从而实现更加复杂的操作。</p><p>Redis中的事务具有以下特点：</p><ul><li>原子性：Redis中的事务是一个原子操作，要么全部执行成功，要么全部执行失败，不会出现部分执行的情况。</li><li>隔离性：Redis中的事务是隔离的，事务中的命令不会被其他客户端请求所干扰。</li><li>可重入性：Redis中的事务是可重入的，可以在一个事务中嵌套另一个事务。</li><li>回滚操作：当事务执行失败时，Redis会自动回滚事务，撤销已执行的命令。</li></ul></blockquote><h3 id="八、Kafka"><a href="#八、Kafka" class="headerlink" title="八、Kafka"></a>八、Kafka</h3><h4 id="1、Kafka的基本概念是什么？"><a href="#1、Kafka的基本概念是什么？" class="headerlink" title="1、Kafka的基本概念是什么？"></a>1、Kafka的基本概念是什么？</h4><blockquote><p>Kafka是一个分布式的消息队列系统，基于发布-订阅模型。它包含了生产者、消费者和Broker三个核心组件。生产者可以将消息发送到Kafka集群，消费者可以从Kafka集群中订阅并消费消息，Broker则是在Kafka集群中的存储和转发节点。</p></blockquote><h4 id="2、Kafka的数据存储模型是什么？"><a href="#2、Kafka的数据存储模型是什么？" class="headerlink" title="2、Kafka的数据存储模型是什么？"></a>2、Kafka的数据存储模型是什么？</h4><blockquote><p>Kafka的数据存储模型是基于日志的。所有的消息都被追加到一个或多个分区中，每个分区都由多个消息组成，每条消息都有一个连续的偏移量。Kafka使用分布式提交日志（Distributed Commit Log）来保存消息，这种方式可以保证高可用性和持久性。</p></blockquote><h4 id="3、Kafka的主要优点是什么？"><a href="#3、Kafka的主要优点是什么？" class="headerlink" title="3、Kafka的主要优点是什么？"></a>3、Kafka的主要优点是什么？</h4><blockquote><ul><li>高吞吐量：Kafka能够处理大量的数据，支持每秒处理几百万条消息。</li><li>可靠性：Kafka使用分布式提交日志来保证消息的持久性和可靠性。</li><li>可扩展性：Kafka的数据分片存储模型支持水平扩展，可以随着数据量的增长而扩展。</li><li>实时性：Kafka的消息能够实时地被消费者订阅和处理。</li><li>灵活性：Kafka支持多种编程语言和平台，可以与各种数据处理系统集成。</li></ul></blockquote><h4 id="4、Kafka的消费者处理如何保障消息的顺序？"><a href="#4、Kafka的消费者处理如何保障消息的顺序？" class="headerlink" title="4、Kafka的消费者处理如何保障消息的顺序？"></a>4、Kafka的消费者处理如何保障消息的顺序？</h4><blockquote><p>在Kafka中，每个主题（Topic）可以被分为多个分区（Partition），每个分区内的消息是有序的，但不同分区的消息是无序的。当一个消费者从一个分区中拉取消息时，Kafka保证消息的顺序不变。但是，当多个消费者同时从多个分区中拉取消息时，Kafka不能保证消息的全局顺序，因为不同的分区的消息是无序的。</p><p>如果应用需要保证消息的全局顺序，可以将消息发送到一个分区中，这样消费者在处理消息时就能保证消息的全局顺序。另外，Kafka还支持消息的批量发送和消费，可以提高消息的吞吐量和效率。</p></blockquote><h4 id="5、Kafka的数据如何保证不被重复消费？"><a href="#5、Kafka的数据如何保证不被重复消费？" class="headerlink" title="5、Kafka的数据如何保证不被重复消费？"></a>5、Kafka的数据如何保证不被重复消费？</h4><blockquote><p>生产者角度：</p><ul><li>设置正确的分区（partition）数量和副本（replication factor）数量：在生产者将消息发送到主题之前，需要考虑主题的分区和副本数量，以确保消息能够在不同的消费者之前均衡地分配和复制。</li><li>采用幂等性：幂等性生产者可以保证即使在网络延迟或重试情况下，也不会发送重复的消息。可以通过设置<code>enable.idempotence=true</code>参数启用。</li></ul><p>消费者角度：</p><ul><li><p>使用消费者组(Consumer Group)：消费者组可以确保同一组中的消费者不会重复消费同一条消息，每个消息只会被组内的一个消费者处理。因此，在使用Kafka时，应该为每个消费者组分配一个唯一的组ID。</p></li><li><p>启用自动提交(offset commit)：Kafka提供了两种提交偏移量(offset)的方式：手动提交和自动提交。启用自动提交可以确保在消费者异常退出或崩溃时，偏移量能够被定期提交到Kafka服务器上。</p></li><li><p>限制消费者的并行度(parallelism)：限制消费者的并行度可以确保同一消费者组中的消费者数量不会过多，减少重复消费的可能性。</p></li></ul></blockquote><h4 id="6、Kafka的消息可靠性如何保证（如何避免消息丢失）？"><a href="#6、Kafka的消息可靠性如何保证（如何避免消息丢失）？" class="headerlink" title="6、Kafka的消息可靠性如何保证（如何避免消息丢失）？"></a>6、Kafka的消息可靠性如何保证（如何避免消息丢失）？</h4><blockquote><p>生产者</p><ul><li>提高消息的可靠性：通过设置参数来保证消息的可靠性，例如将 <code>acks</code> 参数设置为 <code>all</code>，即需要所有的副本都收到消息才认为消息发送成功，这样可以减少消息丢失的可能性。</li><li>使用消息确认机制：在发送消息后，等待 Kafka 返回确认信息，如果确认信息未收到，可以重新发送消息，保证消息不会丢失。</li><li>使用事务机制：通过事务机制可以将多个操作视为一个原子操作，如果其中任何一个操作失败，整个事务将被回滚，这样可以保证消息不会丢失。</li></ul><p>消费者</p><ul><li>提高消息消费的可靠性：通过手动提交偏移量，可以避免由于自动提交偏移量而导致的消息丢失。</li><li>增加消息的重试机制：在处理消息时，如果发现消息处理失败，可以将消息重新放回队列中，等待重新处理，这样可以保证消息不会丢失。</li><li>增加消息的容错机制：在处理消息时，如果发现某个消费者实例异常退出，可以通过增加副本或重新分配消费者实例等方式来保证消息不会丢失。</li></ul></blockquote><h4 id="7、Kafka的副本机制是？"><a href="#7、Kafka的副本机制是？" class="headerlink" title="7、Kafka的副本机制是？"></a>7、Kafka的副本机制是？</h4><blockquote><p>Kafka的副本机制时保证消息高可用性和可靠性的重要手段。Kafka中的每个分区都可以配置多个副本，其中一个副本被称为领导者（Leader），其他副本被称为追随者（Follower）。</p><p>Leader负责处理消息的读写请求，并将数据同步到Follower副本。Follower副本只负责从Leader副本中拉取消息，不参与消息的写入。当Leader副本宕机时，其中一个Follower副本会被选举为新的Leader，继续处理消息的读写请求。</p><p>Kafka的副本机制可以提高系统的可用性和容错性，因为当某个副本宕机时，其他副本可以继续处理消息，保证数据不丢失。此外，Kafka还支持多数据中心复制（Multi-Datacenter Replication），可以将消息复制到不同的数据中心，提高数据的可用性和灾备能力。</p></blockquote><h4 id="8、Kafka为什么能够处理大批量的数据（削峰）"><a href="#8、Kafka为什么能够处理大批量的数据（削峰）" class="headerlink" title="8、Kafka为什么能够处理大批量的数据（削峰）"></a>8、Kafka为什么能够处理大批量的数据（削峰）</h4><blockquote><p>Kafka之所以能够处理大批量的数据，其中一个重要的原因是其具有削峰能力。削峰指的是能够平滑处理突发的数据流量，而不会因为流量突增导致系统崩溃或性能下降的情况。下面是几个可以解释Kafka削峰能力的原因：</p><ul><li>消费者消费数据速度的控制：Kafka消费者可以自行控制消费数据的速度，即可以通过调整消费者的线程数或使用批量消费的方式来控制每个消费者消费的速度。这样可以避免过多的消息堆积在Kafka中，从而平滑处理突发的数据流量。</li><li>消息缓存的机制：Kafka具有消息缓存的机制，即将消息存储在内存中，以提高读写性能。消息缓存可以缓解瞬时数据量的压力，让Kafka能够处理更高的并发请求。</li><li>分区机制的使用：Kafka使用分区机制将主题分为多个分区，每个分区都可以被多个消费者消费。通过分区机制，可以将数据均匀地分布在多个分区中，从而提高了Kafka的并发处理能力。</li><li>异步的数据写入：Kafka生产者使用异步的方式将消息写入Kafka集群中。生产者会将消息存储在本地缓存中，而不是直接发送到Kafka集群，然后再批量地将缓存中的消息发送到Kafka。这样可以避免瞬时大量的请求导致集群性能下降。</li><li>副本机制的使用：Kafka通过复制分区副本的方式来保证数据的可靠性。副本机制可以缓解由于单一节点故障或网络异常等原因导致的数据丢失问题，从而保证了数据的可靠性和Kafka集群的稳定性。同时，多个副本也可以同时处理请求，提高Kafka的并发处理能力。</li></ul></blockquote><h3 id="🌙、网络"><a href="#🌙、网络" class="headerlink" title="🌙、网络"></a>🌙、网络</h3><h4 id="1、OSI与TCP-x2F-IP各层的结构与功能，都有哪些协议？"><a href="#1、OSI与TCP-x2F-IP各层的结构与功能，都有哪些协议？" class="headerlink" title="1、OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议？"></a>1、OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议？</h4><h4 id="2、TCP三次握手与四次挥手"><a href="#2、TCP三次握手与四次挥手" class="headerlink" title="2、TCP三次握手与四次挥手?"></a>2、TCP三次握手与四次挥手?</h4><h4 id="3、TCP、UDP协议的区别"><a href="#3、TCP、UDP协议的区别" class="headerlink" title="3、TCP、UDP协议的区别"></a>3、TCP、UDP协议的区别</h4><h4 id="4、TCP协议如何保证可靠性传输"><a href="#4、TCP协议如何保证可靠性传输" class="headerlink" title="4、TCP协议如何保证可靠性传输"></a>4、TCP协议如何保证可靠性传输</h4><h4 id="5、ARQ协议"><a href="#5、ARQ协议" class="headerlink" title="5、ARQ协议"></a>5、ARQ协议</h4><h4 id="6、滑动窗口和流量控制"><a href="#6、滑动窗口和流量控制" class="headerlink" title="6、滑动窗口和流量控制"></a>6、滑动窗口和流量控制</h4><h4 id="7、拥塞控制"><a href="#7、拥塞控制" class="headerlink" title="7、拥塞控制"></a>7、拥塞控制</h4><h4 id="8、各种协议与HTTP协议之间的关系"><a href="#8、各种协议与HTTP协议之间的关系" class="headerlink" title="8、各种协议与HTTP协议之间的关系"></a>8、各种协议与HTTP协议之间的关系</h4><h4 id="9、HTTP长连接、短链接"><a href="#9、HTTP长连接、短链接" class="headerlink" title="9、HTTP长连接、短链接"></a>9、HTTP长连接、短链接</h4><h4 id="10、HTTP是不保存状态的协议，如何保存用户的状态？"><a href="#10、HTTP是不保存状态的协议，如何保存用户的状态？" class="headerlink" title="10、HTTP是不保存状态的协议，如何保存用户的状态？"></a>10、HTTP是不保存状态的协议，如何保存用户的状态？</h4><h4 id="11、Cookie的作用是什么？和Session有什么区别？"><a href="#11、Cookie的作用是什么？和Session有什么区别？" class="headerlink" title="11、Cookie的作用是什么？和Session有什么区别？"></a>11、Cookie的作用是什么？和Session有什么区别？</h4><h3 id="🌙、数据库"><a href="#🌙、数据库" class="headerlink" title="🌙、数据库"></a>🌙、数据库</h3><h4 id="1、MySQL存储索引"><a href="#1、MySQL存储索引" class="headerlink" title="1、MySQL存储索引"></a>1、MySQL存储索引</h4><h4 id="2、字符集及校验规则"><a href="#2、字符集及校验规则" class="headerlink" title="2、字符集及校验规则"></a>2、字符集及校验规则</h4><h4 id="3、索引"><a href="#3、索引" class="headerlink" title="3、索引"></a>3、索引</h4><h4 id="4、查询缓存的使用"><a href="#4、查询缓存的使用" class="headerlink" title="4、查询缓存的使用"></a>4、查询缓存的使用</h4><h4 id="5、什么是事务"><a href="#5、什么是事务" class="headerlink" title="5、什么是事务"></a>5、什么是事务</h4><h4 id="6、事务的四大特性-ACID"><a href="#6、事务的四大特性-ACID" class="headerlink" title="6、事务的四大特性(ACID)"></a>6、事务的四大特性(ACID)</h4><h4 id="7、并发事务带来哪些问题？"><a href="#7、并发事务带来哪些问题？" class="headerlink" title="7、并发事务带来哪些问题？"></a>7、并发事务带来哪些问题？</h4><h4 id="8、事务隔离级别有哪些？MySQL的默认隔离级别是？"><a href="#8、事务隔离级别有哪些？MySQL的默认隔离级别是？" class="headerlink" title="8、事务隔离级别有哪些？MySQL的默认隔离级别是？"></a>8、事务隔离级别有哪些？MySQL的默认隔离级别是？</h4><h4 id="9、锁机制与InnoDB锁算法"><a href="#9、锁机制与InnoDB锁算法" class="headerlink" title="9、锁机制与InnoDB锁算法"></a>9、锁机制与InnoDB锁算法</h4><h4 id="10、大表优化"><a href="#10、大表优化" class="headerlink" title="10、大表优化"></a>10、大表优化</h4><h4 id="11、解释一下什么池化设计思想。什么事数据库连接池？为什么需要数据库连接池？"><a href="#11、解释一下什么池化设计思想。什么事数据库连接池？为什么需要数据库连接池？" class="headerlink" title="11、解释一下什么池化设计思想。什么事数据库连接池？为什么需要数据库连接池？"></a>11、解释一下什么池化设计思想。什么事数据库连接池？为什么需要数据库连接池？</h4><h4 id="12、分库分表后，id主键如何处理？"><a href="#12、分库分表后，id主键如何处理？" class="headerlink" title="12、分库分表后，id主键如何处理？"></a>12、分库分表后，id主键如何处理？</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记</title>
      <link href="/2023/02/22/kafka-an-zhuang/"/>
      <url>/2023/02/22/kafka-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Docker上启动Kafka"><a href="#一、Docker上启动Kafka" class="headerlink" title="一、Docker上启动Kafka"></a>一、Docker上启动Kafka</h3><h4 id="1、下载zookeeper镜像"><a href="#1、下载zookeeper镜像" class="headerlink" title="1、下载zookeeper镜像"></a>1、下载zookeeper镜像</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull wurstmeister/zookeeper:3.4.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2、下载Kafka镜像"><a href="#2、下载Kafka镜像" class="headerlink" title="2、下载Kafka镜像"></a>2、下载Kafka镜像</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull wurstmeister/kafka:2.13-2.8.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、启动zookeeper"><a href="#3、启动zookeeper" class="headerlink" title="3、启动zookeeper"></a>3、启动zookeeper</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> zookeeper <span class="token parameter variable">-p</span> <span class="token number">2181</span>:2181  <span class="token parameter variable">-t</span> wurstmeister/zookeeper:3.4.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4、启动Kafka"><a href="#4、启动Kafka" class="headerlink" title="4、启动Kafka"></a>4、启动Kafka</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> kafka <span class="token parameter variable">--publish</span> <span class="token number">9092</span>:9092 <span class="token parameter variable">--link</span> zookeeper:zookeeper <span class="token parameter variable">-e</span> <span class="token assign-left variable">KAFKA_BROKER_ID</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token parameter variable">-e</span> <span class="token assign-left variable">HOST_IP</span><span class="token operator">=</span><span class="token number">192.168</span>.1.1  <span class="token parameter variable">-e</span> <span class="token assign-left variable">KAFKA_ZOOKEEPER_CONNECT</span><span class="token operator">=</span>zookeeper:2181 <span class="token parameter variable">-e</span> <span class="token assign-left variable">KAFKA_ADVERTISED_LISTENERS</span><span class="token operator">=</span>PLAINTEXT://192.168.1.1:9092  <span class="token parameter variable">-e</span> <span class="token assign-left variable">KAFKA_ADVERTISED_HOST_NAME</span><span class="token operator">=</span><span class="token number">192.168</span>.1.1 <span class="token parameter variable">-e</span> <span class="token assign-left variable">KAFKA_ADVERTISED_PORT</span><span class="token operator">=</span><span class="token number">9082</span>  <span class="token parameter variable">--restart</span><span class="token operator">=</span>always  <span class="token parameter variable">-t</span>  wurstmeister/kafka:2.13-2.8.1<span class="token comment">## 部分参数含义</span><span class="token assign-left variable">KAFKA_BROKER_ID</span><span class="token operator">=</span><span class="token number">1</span> kafka在集群中的唯一标识<span class="token assign-left variable">KAFKA_ZOOKEEPER_CONNECT</span><span class="token operator">=</span>zookeeper:2181 监听zookeeper的地址 <span class="token assign-left variable">KAFKA_ADVERTISED_LISTENERS</span><span class="token operator">=</span>PLAINTEXT://192.168.1.1:9092 kafka服务器的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5、进入kafka容器"><a href="#5、进入kafka容器" class="headerlink" title="5、进入kafka容器"></a>5、进入kafka容器</h4><ul><li>先查看一下Kafka的镜像ID：docker ps -a</li></ul><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202304211646544.png"></p><ul><li>进入容器：docker exec -it ${CONTAINER ID} &#x2F;bin&#x2F;bash</li><li>进入kafka的bin目录下：cd &#x2F;opt&#x2F;kafka_2.13-2.8.1&#x2F;bin</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## 常见的一些kafka命令</span><span class="token comment"># 创建topicpartitions：分区的数量，提高并发量与负载replication：副本数量</span>kafka-topics.sh --bootstrap-server <span class="token number">127.0</span>.0.1:9092 <span class="token parameter variable">--create</span> <span class="token parameter variable">--topic</span> <span class="token variable">$&#123;topicName&#125;</span> <span class="token parameter variable">--partitions</span> <span class="token variable">$&#123;partipartions&#125;</span> --replication-factor <span class="token variable">$&#123;replication&#125;</span><span class="token comment"># 查看topic详情</span>kafka-topics.bat --bootstrap-server <span class="token number">127.0</span>.0.1:9092 <span class="token parameter variable">--topic</span> <span class="token variable">$&#123;topicName&#125;</span> <span class="token parameter variable">--describe</span><span class="token comment"># 生产消息</span>kafka-console-producer.sh --bootstrap-server localhost:9092 <span class="token parameter variable">--topic</span> <span class="token builtin class-name">test</span><span class="token comment"># 消费消息</span>kafka-console-consumer.sh --bootstrap-server localhost:9092 <span class="token parameter variable">--topic</span> <span class="token builtin class-name">test</span> --from-beginning<span class="token comment"># 查看组</span>kafka-consumer-groups.sh --bootstrap-server <span class="token number">127.0</span>.0.1:9092 <span class="token parameter variable">--describe</span> <span class="token parameter variable">--group</span> flume<span class="token comment"># 删除topic</span>kafka-topics.sh <span class="token parameter variable">--delete</span> --bootstrap-server <span class="token number">192.168</span>.9.20:9092 <span class="token parameter variable">--topic</span> 20220624_student_result<span class="token comment"># 0.9之后的kafka是将消息偏移量存储在kafka自己创建的一个topic内__comsumer_offsets</span><span class="token comment"># 查看消费信息</span>bin/kafka-console-consumer.sh <span class="token parameter variable">--topic</span> __consumer_offsets --bootstrap-server <span class="token number">192.168</span>.9.20:9092 <span class="token parameter variable">--formatter</span> <span class="token string">"kafka.coordinator.group.GroupMetadataManager\<span class="token variable">$OffsetsMessageFormatter</span>"</span> <span class="token parameter variable">--consumer.config</span> config/consumer.properties --from-beginning<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>启动kafka需要把安全组或者防火墙打开，否则可能会出现连接超时的问题。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 容器中可能没有vim等命令</span>可以执行以下命令进行安装<span class="token function">apt-get</span> update<span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令</title>
      <link href="/2022/12/15/linux-chang-yong-ming-ling/"/>
      <url>/2022/12/15/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h5 id="1、Linux-查询命令"><a href="#1、Linux-查询命令" class="headerlink" title="1、Linux 查询命令"></a>1、Linux 查询命令</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> flume<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2、查询端口"><a href="#2、查询端口" class="headerlink" title="2、查询端口"></a>2、查询端口</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -lntp<span class="token operator">|</span><span class="token function">grep</span> <span class="token number">9092</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3、查看文件夹大小</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">du</span> <span class="token parameter variable">-sh</span> <span class="token variable">$&#123;dirName&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4、查看最大打开数</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-a</span><span class="token punctuation">(</span>vim /etc/security/limits.conf<span class="token punctuation">)</span>  一个是打开文件数，一个是打开进程数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5、查看运行的程序</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jps -l（-l 查看具体详情）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>6、分发到其他服务器的命令</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scp（scp <span class="token parameter variable">-r</span> /opt/module/apache-doris-0.15.0/fe hadoop2:/opt/module/apache-doris-0.15.0）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>7、服务器间的拷贝</strong>（scp：分发，rsync：同步，xsync：拷贝）</p><pre class="line-numbers language-none"><code class="language-none">rsync主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。rsync和scp区别：用rsync做文件的复制要比scp的速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。scp -r root@主机名:&#x2F;对应的地址（本机地址）    root@主机名:&#x2F;对应的地址（目标地址）rsync -av root@主机名:&#x2F;对应的地址（本机地址）    root@主机名:&#x2F;对应的地址（目标地址）xsync -av 目录  root@主机名:&#x2F;对应的地址（目标地址）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>8、免密登录</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~ 来到根目录ll <span class="token parameter variable">-al</span>下面的.ssh目录ssh-keygen <span class="token parameter variable">-t</span> rsa 三次回车生成私钥和公钥拷贝到另一台机器ssh-copy-id 机器ip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>9、查看开机启动项</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看开机启动项状态</span>systemctl list-unit-files<span class="token comment"># 设置开机自启项</span>systemctl <span class="token builtin class-name">enable</span> redissystemctl <span class="token builtin class-name">enable</span> nginx.service<span class="token comment"># 启动nginx</span>systemctl start nginx.service<span class="token comment"># 结束nginx</span>systemctl stop nginx.service<span class="token comment"># 重启nginx</span>systemctl restart nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>10、防火墙相关命令</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看防火墙的状态的命令为：</span><span class="token function">sudo</span> systemctl status firewalld<span class="token comment"># 打开防火墙的方式有两种，一种是打开后重启会恢复回原来的状态，命令为：</span><span class="token function">sudo</span> systemctl start firewalld<span class="token comment"># 关闭的</span><span class="token function">sudo</span> systemctl stop firewalld<span class="token comment"># 另一种是打开后重启不会恢复到原来的状态，命令为：这种方式输入命令后要重启系统才会生效。</span><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> firewalld<span class="token comment"># 关闭 </span><span class="token function">sudo</span> systemctl disable firewalld<span class="token comment"># 查看开放的端口</span>firewall-cmd <span class="token parameter variable">--zone</span><span class="token operator">=</span>public --list-ports<span class="token comment"># 添加指定需要开放的端口</span>firewall-cmd --add-port<span class="token operator">=</span><span class="token number">123</span>/tcp <span class="token parameter variable">--permanent</span><span class="token comment"># 查询某个端口是否开放</span>firewall-cmd --query-port<span class="token operator">=</span><span class="token number">666</span>/tcp<span class="token comment"># 重载入添加的端口</span>firewall-cmd <span class="token parameter variable">--reload</span><span class="token comment"># 移除指定端口</span>firewall-cmd <span class="token parameter variable">--permanent</span> --remove-port<span class="token operator">=</span><span class="token number">123</span>/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>11、查看所有节点ntpd服务状态和开机自启动状态</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl status ntpd<span class="token function">sudo</span> systemctl start ntpd<span class="token function">sudo</span> systemctl is-enabled ntpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>12、查看运行内存占用情况</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> stats <span class="token operator">|</span> <span class="token function">grep</span> k8s_mysql-*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>13、查看服务器内存情况</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">free</span> <span class="token parameter variable">-h</span> <span class="token comment"># 查看服务的内存使用情况</span><span class="token function">cat</span> /proc/meminfo <span class="token comment"># 查看内存的具体使用情况</span><span class="token comment"># 可以在命令前加上watch 表示每2秒刷新一次，案例如下：</span><span class="token function">watch</span> <span class="token function">cat</span> /proc/meminfo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA API连接HDFS HA集群</title>
      <link href="/2022/12/01/java-hdfs-ji-qun-lian-jie/"/>
      <url>/2022/12/01/java-hdfs-ji-qun-lian-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用JAVA API连接HDFS时我们需要使用NameNode的地址，开启HA后，两个NameNode可能会主备</p><p>切换，如果连接的那台主机NameNode挂掉了，连接就会失败。HDFS提供了nameservices的方式进行</p><p>访问,这样只要有一个NameNode活着，都可以正常访问。</p><h3 id="1、创建maven，导入pom-xml依赖"><a href="#1、创建maven，导入pom-xml依赖" class="headerlink" title="1、创建maven，导入pom.xml依赖"></a>1、创建maven，导入pom.xml依赖</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> hadoop 依赖 <span class="token operator">--</span><span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>hadoop<span class="token operator">-</span>client<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">3.1</span><span class="token number">.3</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、yaml配置文件加入以下配置"><a href="#2、yaml配置文件加入以下配置" class="headerlink" title="2、yaml配置文件加入以下配置"></a>2、yaml配置文件加入以下配置</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">hadoop</span><span class="token punctuation">:</span>   <span class="token comment"># 集群地址，以（,）分隔</span>  <span class="token key atrule">name-node</span><span class="token punctuation">:</span> hadoop01<span class="token punctuation">:</span><span class="token number">8020</span><span class="token punctuation">,</span>hadoop02<span class="token punctuation">:</span><span class="token number">8020</span><span class="token punctuation">,</span>hadoop03<span class="token punctuation">:</span><span class="token number">8020</span>  <span class="token comment"># hadoop用户</span>  <span class="token key atrule">user</span><span class="token punctuation">:</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、创建HadoopConfig类（将fileSystem初始化到bean容器中）"><a href="#3、创建HadoopConfig类（将fileSystem初始化到bean容器中）" class="headerlink" title="3、创建HadoopConfig类（将fileSystem初始化到bean容器中）"></a>3、创建HadoopConfig类（将fileSystem初始化到bean容器中）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @author zhao * @since 2022-10-19 15:58 */</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>name<span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"hadoop.name-node"</span><span class="token punctuation">,</span> <span class="token string">"hadoop.user"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HadoopConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;hadoop.name-node&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> nameNode<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;hadoop.user&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> user<span class="token punctuation">;</span>    <span class="token class-name">String</span> nameServices <span class="token operator">=</span> <span class="token string">"mycluster"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Configuration conf=new Configuration（）；     * 创建一个Configuration对象时，其构造方法会默认加载hadoop中的两个配置文件，     * 分别是hdfs-site.xml以及core-site.xml，这两个文件中会有访问hdfs所需的参数值，     * 主要是fs.default.name，指定了hdfs的地址，有了这个地址客户端就可以通过这个地址访问hdfs了。     * 即可理解为configuration就是hadoop中的配置信息。     * @return     */</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"fileSystem"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">FileSystem</span> <span class="token function">createFs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        <span class="token comment">//读取配置文件</span>        <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span>Configuration</span> conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span>Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// hdfs集群节点</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nameNodesAddr <span class="token operator">=</span> nameNode<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 节点nn的个数</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nameNodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>nameNodesAddr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nameNodes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nameNodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nn"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">String</span> nodes <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">,</span> nameNodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        conf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">FS_DEFAULT_FS</span><span class="token punctuation">,</span> <span class="token string">"hdfs://"</span> <span class="token operator">+</span> nameServices<span class="token punctuation">)</span><span class="token punctuation">;</span>        conf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"dfs.nameservices"</span><span class="token punctuation">,</span> nameServices<span class="token punctuation">)</span><span class="token punctuation">;</span>        conf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"dfs.ha.namenodes."</span> <span class="token operator">+</span> nameServices<span class="token punctuation">,</span> nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nameNodesAddr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            conf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"dfs.namenode.rpc-address."</span> <span class="token operator">+</span> nameServices <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> nameNodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nameNodesAddr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        conf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"dfs.client.failover.proxy.provider."</span> <span class="token operator">+</span> nameServices<span class="token punctuation">,</span><span class="token string">"org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        conf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">DSF_CLIENT_USE_DATANODE_HOSTNAME</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">URI</span> uri <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://"</span> <span class="token operator">+</span> nameServices <span class="token operator">+</span> <span class="token string">":8020"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// hdfs单节点部署</span><span class="token comment">//        conf.set(FS_DEFAULT_FS, nameNode);</span><span class="token comment">//        URI uri = new URI(nameNode.trim());</span>        <span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>uri<span class="token punctuation">,</span> conf<span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"HDFS --》 fileSystem 初始化成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> fs<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 连接地址     * example：hdfs://hdp-01:8020     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token constant">FS_DEFAULT_FS</span> <span class="token operator">=</span>  <span class="token string">"fs.defaultFS"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 配置副本个数     * Integer     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token constant">DFS_REPLICATION</span> <span class="token operator">=</span>  <span class="token string">"dfs.replication"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 是否使用主机节点名称     * true OR false     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token constant">DSF_CLIENT_USE_DATANODE_HOSTNAME</span> <span class="token operator">=</span>  <span class="token string">"dfs.client.use.datanode.hostname"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、Hadoop常用的一些方法（引入FileSystem即可使用）"><a href="#4、Hadoop常用的一些方法（引入FileSystem即可使用）" class="headerlink" title="4、Hadoop常用的一些方法（引入FileSystem即可使用）"></a>4、Hadoop常用的一些方法（引入FileSystem即可使用）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @author zhao * @since 2022-10-19 16:04 */</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HadoopTemplate</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">FileSystem</span> fileSystem<span class="token punctuation">;</span>    <span class="token comment">//  -----------------   一些常用方法  -----------------</span>    <span class="token comment">// TODO: 2022/8/4 后续有用其他的到再继续补充</span>    <span class="token comment">/**     * 检查文件或者文件夹是否存在     * @param filename  文件夹名称     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkFileExist</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Path</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> fileSystem<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 创建文件夹     * @param dirName   文件夹名称     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token class-name">String</span> dirName<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkFileExist</span><span class="token punctuation">(</span>dirName<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Path</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>dirName<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Create and Write :"</span> <span class="token operator">+</span> f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" to hdfs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> fileSystem<span class="token punctuation">.</span><span class="token function">mkdirs</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"创建文件夹失败，异常信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 文件上传     * @param delSrc      是否删除元数据     * @param overwrite   是否允许覆盖     * @param sourceFilePath  元数据路径     * @param targetFilePath  目的地路径     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">putFile</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> delSrc<span class="token punctuation">,</span> <span class="token keyword">boolean</span> overwrite<span class="token punctuation">,</span> <span class="token class-name">String</span> sourceFilePath<span class="token punctuation">,</span> <span class="token class-name">String</span> targetFilePath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Path</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>sourceFilePath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Path</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>targetFilePath<span class="token punctuation">)</span><span class="token punctuation">;</span>            fileSystem<span class="token punctuation">.</span><span class="token function">copyFromLocalFile</span><span class="token punctuation">(</span>delSrc<span class="token punctuation">,</span> overwrite<span class="token punctuation">,</span> source<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件上传失败，异常信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 文件下载     * @param delSrc           是否删除原文件     * @param sourceHdfsPath   源文件路径HDFS     * @param targetFilePath   目标路径Win     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">downloadFile</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> delSrc<span class="token punctuation">,</span> <span class="token class-name">String</span> sourceHdfsPath<span class="token punctuation">,</span> <span class="token class-name">String</span> targetFilePath<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Path</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>sourceHdfsPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Path</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>targetFilePath<span class="token punctuation">)</span><span class="token punctuation">;</span>            fileSystem<span class="token punctuation">.</span><span class="token function">copyToLocalFile</span><span class="token punctuation">(</span>delSrc<span class="token punctuation">,</span> source<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件下载失败，异常信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 文件下载     * @param delSrc           是否删除原文件     * @param sourceHdfsPath   源文件路径HDFS     * @param targetFilePath   目标路径Win     * @param useRawLocalFileSystem     是否开启本地模式 --> 文件的校验     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">downloadFile</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> delSrc<span class="token punctuation">,</span> <span class="token class-name">String</span> sourceHdfsPath<span class="token punctuation">,</span> <span class="token class-name">String</span> targetFilePath<span class="token punctuation">,</span> <span class="token keyword">boolean</span> useRawLocalFileSystem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Path</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>sourceHdfsPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Path</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>targetFilePath<span class="token punctuation">)</span><span class="token punctuation">;</span>            fileSystem<span class="token punctuation">.</span><span class="token function">copyToLocalFile</span><span class="token punctuation">(</span>delSrc<span class="token punctuation">,</span> source<span class="token punctuation">,</span> target<span class="token punctuation">,</span> useRawLocalFileSystem<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件下载失败，异常信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 删除文件或目录  注：删除非空目录时需要设置recursive，否则将无法删除     * @param delPath   删除路径     * @param recursive 是否递归删除     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">delFile</span><span class="token punctuation">(</span><span class="token class-name">String</span> delPath<span class="token punctuation">,</span> <span class="token keyword">boolean</span> recursive<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> isDel <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Path</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>delPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            isDel <span class="token operator">=</span> fileSystem<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> recursive<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"删除失败，异常信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> isDel<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 文件或文件夹的更名和移动     * @param sourcePath    源路径     * @param targetPath    目标路径     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">renameOrMoveFile</span><span class="token punctuation">(</span><span class="token class-name">String</span> sourcePath<span class="token punctuation">,</span> <span class="token class-name">String</span> targetPath<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            flag <span class="token operator">=</span> fileSystem<span class="token punctuation">.</span><span class="token function">rename</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>sourcePath<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>targetPath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件更名或移动失败，错误信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> flag<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 查看文件详情信息     * @param pathString    需要查看的路径     * @param recursive     是否需要递归获取     */</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LocatedFileStatus</span><span class="token punctuation">></span></span> <span class="token function">getFileDetail</span><span class="token punctuation">(</span><span class="token class-name">String</span> pathString<span class="token punctuation">,</span> <span class="token keyword">boolean</span> recursive<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LocatedFileStatus</span><span class="token punctuation">></span></span> locatedFileStatusList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取所有文件信息</span>            <span class="token class-name">RemoteIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LocatedFileStatus</span><span class="token punctuation">></span></span> listFiles <span class="token operator">=</span> fileSystem<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>pathString<span class="token punctuation">)</span><span class="token punctuation">,</span> recursive<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 遍历将文件添加到集合当中</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>listFiles<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">LocatedFileStatus</span> fileStatus <span class="token operator">=</span> listFiles<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                locatedFileStatusList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>fileStatus<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"获取文件详情失败，错误信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> locatedFileStatusList<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取所有文件信息样本案例     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getFileDetailExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取所有文件信息</span>        <span class="token class-name">RemoteIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LocatedFileStatus</span><span class="token punctuation">></span></span> listFiles <span class="token operator">=</span> fileSystem<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历文件</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>listFiles<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">LocatedFileStatus</span> fileStatus <span class="token operator">=</span> listFiles<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======= "</span> <span class="token operator">+</span> fileStatus<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"权限："</span> <span class="token operator">+</span> fileStatus<span class="token punctuation">.</span><span class="token function">getPermission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所属："</span> <span class="token operator">+</span> fileStatus<span class="token punctuation">.</span><span class="token function">getOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"属组："</span> <span class="token operator">+</span> fileStatus<span class="token punctuation">.</span><span class="token function">getGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"长度："</span> <span class="token operator">+</span> fileStatus<span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"上次修改时间"</span> <span class="token operator">+</span> fileStatus<span class="token punctuation">.</span><span class="token function">getModificationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"副本："</span> <span class="token operator">+</span> fileStatus<span class="token punctuation">.</span><span class="token function">getReplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"块大小"</span> <span class="token operator">+</span> fileStatus<span class="token punctuation">.</span><span class="token function">getBlockSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"名称："</span> <span class="token operator">+</span> fileStatus<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取块信息</span>            <span class="token class-name">BlockLocation</span><span class="token punctuation">[</span><span class="token punctuation">]</span> blockLocations <span class="token operator">=</span> fileStatus<span class="token punctuation">.</span><span class="token function">getBlockLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"块信息："</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>blockLocations<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 输出路径下的所有文件是文件还是文件夹     * @param path  路径     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">isFileOrDir</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">FileStatus</span><span class="token punctuation">[</span><span class="token punctuation">]</span> listStatus <span class="token operator">=</span> fileSystem<span class="token punctuation">.</span><span class="token function">listStatus</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">FileStatus</span> status <span class="token operator">:</span> listStatus<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"文件："</span> <span class="token operator">+</span> status<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"目录："</span> <span class="token operator">+</span> status<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 读取文件内容     * @param dst 目标文件     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token class-name">String</span> dst<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Path</span> srcPath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">InputStream</span> in <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> content <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            in <span class="token operator">=</span> fileSystem<span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span>srcPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//复制到标准输出流</span><span class="token comment">//            IOUtils.copyBytes(in, System.out, 4096, false);</span>            content <span class="token operator">=</span> <span class="token function">streamToString</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件内容读取失败，错误信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> content<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 复制文件     * @param inputStream   需要复制的文件流     * @param filePath      复制到的文件路径     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">copyFile</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> inputStream<span class="token punctuation">,</span> <span class="token class-name">String</span> filePath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Path</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">FSDataOutputStream</span> fsDataOutputStream <span class="token operator">=</span> fileSystem<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> read <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>read <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                fsDataOutputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> read<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            fsDataOutputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fsDataOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件内容读取失败，错误信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取Hdfs上的文件流     * @param fileSystemPath 文件路径     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">InputStream</span> <span class="token function">getFileInputStream</span><span class="token punctuation">(</span><span class="token class-name">String</span> fileSystemPath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Path</span> srcPath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>fileSystemPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">InputStream</span> in <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            in <span class="token operator">=</span> fileSystem<span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span>srcPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件内容读取失败，错误信息："</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> in<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取路径底下所有的文件路径     * @param path  目录位置     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Path</span><span class="token punctuation">></span></span> <span class="token function">getAllFilePath</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Path</span><span class="token punctuation">></span></span> filePaths <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">RemoteIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LocatedFileStatus</span><span class="token punctuation">></span></span> listFiles <span class="token operator">=</span> fileSystem<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>listFiles<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">LocatedFileStatus</span> fileStatus <span class="token operator">=</span> listFiles<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                filePaths<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>fileStatus<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> filePaths<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 读取文件流数据     * @param inputStream     * @return     */</span>    <span class="token annotation punctuation">@SneakyThrows</span>    <span class="token keyword">public</span> <span class="token class-name">StringBuffer</span> <span class="token function">streamToString</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> inputStream<span class="token punctuation">,</span> <span class="token class-name">String</span> charsetName<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">InputStreamReader</span> isReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            isReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">,</span> charsetName<span class="token punctuation">)</span><span class="token punctuation">;</span>            br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>isReader<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//循环逐行读取</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>br<span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件流读取发生异常 ---》"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 关闭流</span>            br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sb<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Hdfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hdfs </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker随笔</title>
      <link href="/2022/12/01/docker-xue-xi-bi-ji/"/>
      <url>/2022/12/01/docker-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>要理解 Docker 的内部构建，必须知道Docker 包括三个基本概念:</p><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul><h4 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h4><h5 id="一、镜像-x2F-容器"><a href="#一、镜像-x2F-容器" class="headerlink" title="一、镜像 &#x2F; 容器"></a><em><strong>一、镜像 &#x2F; 容器</strong></em></h5><ul><li><strong>启动时交互</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span>  镜像名称【-i：交互，-t：伪终端，-d：守护式容器】【--name aaa】docker run <span class="token parameter variable">-it</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 tomcat 小p指定端口映射，大P随机端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>查看日志</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> logs <span class="token parameter variable">-tf</span> <span class="token parameter variable">--tail</span> <span class="token number">3</span> 4e237e0e8f08<span class="token punctuation">(</span>容器id<span class="token punctuation">)</span>：【-t：查看内容，-f加上查看时间】<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>查看容器中运行进程的信息</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">top</span> 容器id <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>重新进入容器</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> attach 容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>重新进入容器（加强版）</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器id /bin/bash <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>直接在外部获取容器内的信息</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-t</span> 容器id <span class="token function">ls</span> <span class="token parameter variable">-l</span> /tmp（所以exec比attach强大）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>查看运行的相关信息</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> inspect 容器id <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>docker帮助，相当于文档</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token parameter variable">--help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>重启、删除、启动docker</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart<span class="token punctuation">\</span>stop<span class="token punctuation">\</span>start <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>查看镜像</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dcoker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>运行镜像</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>a表示列出所有的镜像 q表示列出所有的id</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> images 【-qa】<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>拉取镜像</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull 某个镜像的名字<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>删除镜像</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> rmi 【-f】 某个镜像的名字 ：删除镜像    -f：强制删除以空格分割  删除多个镜像<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>查看有几个容器在运行</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> ps（【-l：上一次运行的】【-a：所有运行的】【-n num：显示几次运行的】【-q静默模式：只显示容器编号】【--no-trunc：不截断输出】）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>退出容器</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">exit（推出关闭） CTRL+P+Q（退出不关闭）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>启动容器</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> start/stop/restart/kill/rm 容器编号删除如果强制删除就加 <span class="token parameter variable">-f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>批量删除</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-qa</span><span class="token variable">)</span></span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-qa</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">docker</span> <span class="token function">rm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>提交镜像</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span>“提交的描述信息” <span class="token parameter variable">-a</span><span class="token operator">=</span>“作者” 容器ID 要创建的目标敬香茗：【标签名】<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>容器拷贝到主机</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">cp</span> 容器ID:容器路径 主机路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>容器数据卷（容器的持久化，容器间集成、数据的共享）</strong></p><ul><li>宿主机和容器的数据共享（容器的挂载）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /myDatavolume:/dataVolumeContainer centos<span class="token punctuation">(</span>容器名称<span class="token punctuation">)</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /myDatavolume:/dataVolumeContainer:ro centos<span class="token punctuation">(</span>容器名称<span class="token punctuation">)</span> 只读<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>DockerFile（编写 构建 执行）</p><p>DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本</p><ul><li>手动编写一个DockerFile文件，必须要符合file的规范</li><li>有这个文件后，直接docker build命令执行，获得一个自定义的镜像</li><li>启动（run）</li></ul><pre class="line-numbers language-none"><code class="language-none">docker build -f &#x2F;mydocker&#x2F;Dockerfile -t zjb&#x2F;centos .自己重新构建的镜像<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token comment"># volume test</span><span class="token instruction"><span class="token keyword">FROM</span> centos</span><span class="token instruction"><span class="token keyword">VOLUME</span> [<span class="token string">"/dataVolumeContainer1"</span>,<span class="token string">"/dataVolumeCtontainer2"</span>]</span><span class="token instruction"><span class="token keyword">CMD</span> echo <span class="token string">"finished,---------success1"</span></span><span class="token instruction"><span class="token keyword">CMD</span> /bin/bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>容器间能实现数据卷的共享</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> dc02 --volumes-from dc01 zjb/centos <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除dc10，dc02修改后dc03可以访问</p><p>删除dc02后dc03可以访问</p><p>新建dc04集成dc03后在删除dc03可以访问</p><p>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用为止</p></li></ul></li><li><p>DockerFile体系结构（保留字指令）</p></li></ul><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011557216.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub 博客搭建</title>
      <link href="/2022/12/01/hexo-github-bo-ke-da-jian/"/>
      <url>/2022/12/01/hexo-github-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-GitHub-博客搭建"><a href="#Hexo-GitHub-博客搭建" class="headerlink" title="Hexo + GitHub 博客搭建"></a>Hexo + GitHub 博客搭建</h1><p>前置条件</p><p>1、首先要有一个github账号 </p><p>2、其次安装node.js，npm依赖 </p><p>3、然后安装git工具 </p><h4 id="1、Git的安装："><a href="#1、Git的安装：" class="headerlink" title="1、Git的安装："></a>1、Git的安装：</h4><p>你可在git官网中根据自己的需要进行下载：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>打开之后你将看到如下内容，无电脑<code>download for Windows</code>：</p><p>将其下载到指定的磁盘，然后Windows系统下傻瓜式安装即可。安装好后我们打开cmd终端（win+r </p><p>-&gt; 输入cmd -&gt; 回车），执行<code>git --version</code>，若出现<code>git version 2.19.2.windows.1</code>之类的版输</p><p>出，那么恭喜你已经成功安装，离完成建站近了一步。</p><h4 id="2、Node-js的安装："><a href="#2、Node-js的安装：" class="headerlink" title="2、Node.js的安装："></a>2、Node.js的安装：</h4><p>Hexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。</p><p><strong>windows：</strong>下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。</p><p>最后安装好之后，按Win+R打开命令提示符，输入node -v 和 npm -v，如果出现版本号，那么就安装</p><p>成功了。</p><p>安装完后，打开命令行终端，输入:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-v</span><span class="token function">npm</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>检查一下有没有安装成功</p><h4 id="3、安装Hexo"><a href="#3、安装Hexo" class="headerlink" title="3、安装Hexo"></a>3、安装Hexo</h4><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的</p><p>博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>比如我的博客文件都存放在D:\Study\Blog目录下。</p><p>在该目录下右键点击Git Bash Here，打开git的控制台窗口，操作都在git控制台进行。</p><p>① 定位到该目录下，输入<code>npm install -g hexo-cli</code>安装<code>Hexo</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>至此<code>hexo</code>就安装完了。</p><p>② 接下来初始化一下<code>hexo</code>,即初始化我们的网站，进入我们主题根目录Hexo，输入<code>hexo init</code>初始化文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个Hexo可以自己取什么名字都行，然后，接着输入<code>npm install</code>安装必备的组件。</p><p>新建完成后，指定文件夹<code>Hexo</code>目录下有：</p><ul><li><code>node_modules:</code> 依赖包</li><li><code>public：</code>存放生成的页面</li><li><code>scaffolds：</code>生成文章的一些模板</li><li><code>source：</code>用来存放你的文章</li><li><code>themes：</code>主题**</li><li><code>_config.yml:</code> 博客的配置文件**</li></ul><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在浏览器地址栏输入“<a href="http://localhost:4000/%E2%80%9D%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%88%9A%E5%88%9B%E5%BB%BA%E7%9A%84%E9%A1%B5%E9%9D%A2">http://localhost:4000/”打开页面，即可看到刚创建的页面</a></p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011050698.png"></p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h4 id="4、注册Github账号创建个人仓库"><a href="#4、注册Github账号创建个人仓库" class="headerlink" title="4、注册Github账号创建个人仓库"></a>4、注册<a href="https://so.csdn.net/so/search?q=Github&spm=1001.2101.3001.7020">Github</a>账号创建个人仓库</h4><p>打开自己的<a href="https://github.com/">https://github.com/</a>，新建一个项目仓库<code>New repository</code></p><p>注意！！！仓库名称一定得是xxx.github.io</p><blockquote><p>要创建一个和你用户名相同的仓库，后面加.<code>http://github.io</code>，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是<code>http://xxxx.github.io</code>，其中xxx就是你注册GitHub的用户名。例如我的：<code>http://Jovinbin.github.io</code></p></blockquote><h4 id="5、生成SSH添加到GitHub"><a href="#5、生成SSH添加到GitHub" class="headerlink" title="5、生成SSH添加到GitHub"></a>5、生成SSH添加到GitHub</h4><p>生成<code>SSH</code>添加到<code>GitHub</code>，连接<code>Github</code>与本地。</p><p>右键打开<code>git bash</code>，然后输入下面命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"yourname"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：第一次使用git后需要将用户名和邮箱进行初始化</p><p>这里的<code>yourname</code>输入你的<code>GitHub</code>用户名，<code>youremail</code>输入你<code>GitHub</code>的邮箱。这样<code>GitHub</code>才能知</p><p>道你是不是对应它的账户。例如我的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"zjb"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"1097204334@qq.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后创建<code>SSH</code>,一路回车</p><blockquote><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候会生成.ssh文件夹。在git bash中输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>打开<a href="http://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便取</p><p>一个都可以，把你的<code>id_rsa.pub</code>里面的信息复制进去。如图：</p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011051050.png"></p><p>在<code>git bash</code>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011051865.png"></p><h4 id="6、将hexo部署到GitHub"><a href="#6、将hexo部署到GitHub" class="headerlink" title="6、将hexo部署到GitHub"></a>6、将hexo部署到GitHub</h4><p>这一步，我们就可以将<code>hexo</code>和<code>GitHub</code>关联起来，也就是将<code>hexo</code>生成的文章部署到<code>GitHub</code>上，打开</p><p>博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种</p><p>信息。</p><p>修改最后一行的配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repository</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/gaoziman/gaoziman.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>repository</code>修改为你自己的<code>github</code>项目地址即可就是部署时，告诉工具，将生成网页通过<code>git</code>方式</p><p>上传到你对应的链接仓库中。</p><p>这个时候需要先安装<code>deploy-git</code> ，也就是部署的命令,这样你才能用命令部署到<code>GitHub</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后执行如下命令：其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。 <code>hexo generate</code>顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写 ，<code>hexo deploy</code>部署文章，可以用<code>hexo d</code>缩写</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean<span class="token comment">#清除缓存</span>hexo g<span class="token comment">#生成静态页面</span>hexo d<span class="token comment">#启动服务器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>得到下图就说明部署成功了，过一会儿就可以在<a href="http://jovinbin.github.io/">http://Jovinbin.github.io</a> 这个网站看到你的博客了！！</p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011051077.png"></p><h4 id="7、Hexo-命令"><a href="#7、Hexo-命令" class="headerlink" title="7、Hexo 命令"></a>7、Hexo 命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo <span class="token parameter variable">-g</span> <span class="token comment">#安装Hexo</span><span class="token function">npm</span> update hexo <span class="token parameter variable">-g</span> <span class="token comment">#升级</span>hexo init <span class="token comment">#初始化博客</span>命令简写hexo n <span class="token string">"我的博客"</span> <span class="token operator">==</span> hexo new <span class="token string">"我的博客"</span> <span class="token comment">#新建文章</span>hexo g <span class="token operator">==</span> hexo generate <span class="token comment">#生成静态页面</span>hexo s <span class="token operator">==</span> hexo server <span class="token comment">#启动服务预览</span>hexo d <span class="token operator">==</span> hexo deploy <span class="token comment">#部署</span>hexo server <span class="token comment">#Hexo会监视文件变动并自动更新，无须重启服务器</span>hexo server <span class="token parameter variable">-s</span> <span class="token comment">#静态模式</span>hexo server <span class="token parameter variable">-p</span> <span class="token number">5000</span> <span class="token comment">#更改端口</span>hexo server <span class="token parameter variable">-i</span> <span class="token number">192.168</span>.1.1 <span class="token comment">#自定义 IP</span>hexo clean <span class="token comment">#清除缓存，若是网页正常情况下可以忽略这条命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Doris随笔</title>
      <link href="/2022/11/18/doris-xue-xi-bi-ji/"/>
      <url>/2022/11/18/doris-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Doris（PB级别数据库）"><a href="#Doris（PB级别数据库）" class="headerlink" title="Doris（PB级别数据库）"></a>Doris（PB级别数据库）</h1><p>mysql -h localhost -P9030 -u -p</p><h5 id="①-查看表结构"><a href="#①-查看表结构" class="headerlink" title="① 查看表结构"></a><strong>① 查看表结构</strong></h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">desc table （all）;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>② 通过命令查看完成状态</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW ALTER TABLE ROLLUP;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>③ 查看动态分区表调度情况</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW DYNAMIC PARTITION TABLES; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>④ 查看表的分区</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW PARTITIONS FROM TABLES;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>⑤ 查看物化视图是否创建成功</strong> (Version 0.13)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW ALTER TABLE MATERIALIZED VIEW FROM test_db;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>⑥ 删除物化视图</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP MATERIALIZED VIEW 物化视图名 on Base 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>⑦ 创建物化索引</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create materialized view mv_1 as select store_id,record_id,seller_id, sale_date,sale_amt from sales_records;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>⑧ 修改名字 </p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE table1 RENAME table2;ALTER TABLE example_table RENAME ROLLUP rollup1 rollup2;ALTER TABLE example_table RENAME PARTITION p1 p2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑨ 导入链路相关命令</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">查看导入：show load order by createtime desc limit 1\G；    show load；取消导入：CANCEL LOAD [FROM db_name] WHERE LABEL&#x3D;”load_label”; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>⑩ routine load 导入任务</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">展示导入任务：show routine load\G;暂停名称为 test1 的例行导入作业：PAUSE ROUTINE LOAD FOR test1;暂停所有正在运行的例行导入作业：PAUSE ALL ROUTINE LOAD;恢复名称为 test1 的例行导入作业：RESUME ROUTINE LOAD FOR test1;恢复所有暂停中的例行导入作业：RESUME ALL ROUTINE LOAD;停止名称为 test1 的例行导入作业：STOP ROUTINE LOAD FOR test1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⭕ <strong>查看数据库信息</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show proc &quot;&#x2F;statistic&quot;；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>⭕<strong>查看信息</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW PROC &#39;&#x2F;dbs&#39;;SHOW PROC &#39;&#x2F;dbs&#x2F;11048&#x2F;32003&#x2F;partitions&#x2F;32131&#x2F;32004&#39;;show proc &quot;&#x2F;cluster_balance&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>索引</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">创建索引：CREATE INDEX table_bitmap ON table1 (siteid) USING BITMAP COMMENT  &#39;table1_bitmap_index&#39;; 查看索引：SHOW INDEX[ES] FROM [db_name.]table_name [FROM database]; 或者 SHOW KEY[S] FROM [db_name.]table_name [FROM database]; 删除索引：DROP INDEX IF EXISTS table_bitmap ON test_db.table1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常用命令</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">查看配置信息：show variables;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​Doris 的架构很简洁，只设 FE(Frontend)、BE(Backend)两种角色、两个进程，<strong>不依赖于</strong> </p><p><strong>外部组件</strong>，方便部署和运维，FE、BE 都可线性扩展。 </p><p>⚫   <strong>FE（Frontend）</strong>：存储、维护集群<strong>元数据</strong>；负责接收、解析查询请求，规划查询计划， 调度查询执行，返回查询结果。主要有三个角色： </p><p>​（1）Leader 和 Follower：主要是用来达到元数据的高可用，保证单节点宕机的情况下， </p><p>元数据能够实时地在线恢复，而不影响整个服务。 </p><p>​（2）Observer：用来扩展查询节点，同时起到元数据备份的作用。如果在发现集群压力 </p><p>非常大的情况下，需要去扩展整个查询的能力，那么可以加 observer 的节点。observer 不 </p><p>参与任何的写入，只参与读取。</p><p>⚫ <strong>BE（Backend）</strong>：负责<strong>物理数据的存储和计算</strong>；依据 FE 生成的物理计划，分布式地执行查询。 </p><p>​数据的可靠性由 BE 保证，BE 会对整个数据存储多副本或者是三副本。副本数可根据 </p><p>需求动态调整。 </p><p><strong>1、sql查看状态</strong>（mysql -h hadoop1 -P 9030 -uroot -p）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW PROC &#39;&#x2F;backends&#39;;查看BE状态SHOW PROC &quot;&#x2F;brokers&quot;;查看broker状态SHOW PROC &#39;&#x2F;frontends&#39;;查看FE状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.2.2 Partition &amp; Tablet</strong> </p><p>​在 Doris 的存储引擎中，用户数据首先被划分成若干个分区（Partition），划分的规则通 常是按照用户指定的分区列进行范围划分，比如按时间划分。而在每个分区内，数据被进一 步的按照 Hash 的方式分桶，分桶的规则是要找用户指定的分桶列的值进行 Hash 后分桶。 每个分桶就是一个数据分片（Tablet），也是数据划分的最小逻辑单元。 </p><p>⚫ Tablet 之间的数据是没有交集的，独立存储的。Tablet 也是数据移动、复制等操作 </p><p>的最小物理存储单元。 </p><p>⚫ Partition 可以视为是逻辑上最小的管理单元。数据的导入与删除，都可以或仅能针 </p><p>对一个 Partition 进行</p><p><strong>3.4.1</strong> <strong>列定义</strong> </p><p>​以 AGGREGATE KEY 数据模型为例进行说明。更多数据模型参阅 Doris 数据模型。 列的基本类型，可以通过在 mysql-client 中执行 HELP CREATE TABLE; 查看。 AGGREGATE KEY 数据模型中，所有没有指定聚合方式（SUM、REPLACE、MAX、 MIN）的列视为 Key 列。而其余则为 Value 列。 定义列时，可参照如下建议： </p><p>➢ Key 列必须在所有 Value 列之前。 </p><p>➢ 尽量选择整型类型。因为整型类型的计算和查找比较效率远高于字符串。 </p><p>➢ 对于不同长度的整型类型的选择原则，遵循够用即可。 </p><p>➢ 对于 VARCHAR 和 STRING 类型的长度，遵循 够用即可。 </p><p>➢ 所有列的总字节长度（包括 Key 和 Value）不能超过 100KB。</p><p><strong>3.4.2</strong> <strong>分区与分桶</strong> </p><p>​Doris 支持两层的数据划分。第一层是 Partition，支持 Range 和 List 的划分方式。第二 层是 Bucket（Tablet），仅支持 Hash 的划分方式。 也可以仅使用一层分区。使用一层分区时，只支持 Bucket 划分。</p><p><strong>3.4.2.1 Partition</strong> </p><p>➢ Partition 列可以指定一列或多列。分区类必须为 KEY 列。多列分区的使用方式在后面介绍。 </p><p>➢ 不论分区列是什么类型，在写分区值时，都需要加<strong>双引号</strong>。 </p><p>➢ 分区数量理论上没有上限。 </p><p>➢ 当不使用 Partition 建表时，系统会自动生成一个和表名同名的，全值范围的 Partition。该 Partition 对用户不可见，并且不可删改。 </p><p><strong>1）Range 分区</strong> （动态分区列数据不能为Date）</p><p>​分区列通常为时间列，以方便的管理新旧数据。不可添加范围重叠的分区。</p><p><strong>2）List 分区</strong> </p><p>​分 区 列支 持 BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, LARGEINT, DATE,  DATETIME, CHAR, VARCHAR 数据类型，分区值为枚举值。只有当数据为目标分区枚举值其中之一时，才可以命中分区。不可添加范围重叠的分区。</p><p><strong>3.4.2.2 Bucket</strong> </p><p>（1）如果使用了 Partition，则 DISTRIBUTED … 语句描述的是数据在各个分区内的划 </p><p>分规则。如果不使用 Partition，则描述的是对整个表的数据的划分规则。 </p><p>（2）分桶列可以是多列，但<strong>必须为</strong> <strong>Key</strong> <strong>列</strong>。分桶列可以和 Partition 列相同或不同。 </p><p>（3）分桶列的选择，是在 查询吞吐 和 查询并发 之间的一种权衡： </p><p>​① 如果选择多个分桶列，则数据分布更均匀。 </p><p>​如果一个查询条件不包含所有分桶列的等值条件，那么该查询会触发所有分桶同时 </p><p>扫描，这样查询的吞吐会增加，单个查询的延迟随之降低。这个方式适合大吞吐低并发 </p><p>的查询场景。 </p><p>​② 如果仅选择一个或少数分桶列，则对应的点查询可以仅触发一个分桶扫描。 </p><p>​此时，当多个点查询并发时，这些查询有较大的概率分别触发不同的分桶扫描，各 </p><p>个查询之间的 IO 影响较小（尤其当不同桶分布在不同磁盘上时），所以这种方式适合 </p><p>高并发的点查询场景。 </p><p>（4）分桶的数量理论上没有上限。 </p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011054585.png"></p><p><strong>3.7 Rollup</strong> （rollup可以调整列的顺序，调整前缀索引的顺序）</p><p>​ROLLUP 在多维分析中是“上卷”的意思，即将数据按某种指定的粒度进行进一步聚合。 </p><p><strong>3.7.4 ROLLUP</strong> <strong>的几点说明</strong> </p><p>⚫ ROLLUP 最根本的作用是提高某些查询的查询效率（无论是通过聚合来减少数据 量，还是修改列顺序以匹配前缀索引）。因此 ROLLUP 的含义已经超出了“上卷” 的范围。这也是为什么在源代码中，将其命名为 Materialized Index（物化索引）的 原因。</p><p>⚫ ROLLUP 是附属于 Base 表的，可以看做是 Base 表的一种辅助数据结构。用户可以在 Base表的基础上，创建或删除 ROLLUP，但是不能在查询中显式的指定查询某 </p><p>ROLLUP。是否命中 ROLLUP 完全由 Doris 系统自动决定。 </p><p>⚫ ROLLUP 的数据是独立物理存储的。因此，创建的 ROLLUP 越多，占用的磁盘空间也就越大。同时对导入速度也会有影响（导入的 ETL 阶段会自动产生所有ROLLUP 的数据），但是不会降低查询效率（只会更好）。 </p><p>⚫ ROLLUP 的数据更新与 Base 表是完全同步的。用户无需关心这个问题。 </p><p>⚫ ROLLUP 中列的聚合方式，与 Base 表完全相同。在创建 ROLLUP 无需指定，也不能修改。 </p><p>⚫ 查询能否命中 ROLLUP 的一个必要条件（非充分条件）是，查询所涉及的所有列（包括 select list 和 where 中的查询条件列等）都存在于该 ROLLUP 的列中。否则，查询只能命中 Base 表。 </p><p>⚫ 某些类型的查询（如 count(*)）在任何条件下，都无法命中 ROLLUP。具体参见接下来的聚合模型的局限性一节。 </p><p>⚫ 可以通过 EXPLAIN your_sql; 命令获得查询执行计划，在执行计划中，查看是否命 中 ROLLUP。 </p><p>⚫ 可以通过 DESC tbl_name ALL; 语句显示 Base 表和所有已创建完成的 ROLLUP。</p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011054941.png"></p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011054412.png"></p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011055054.png"></p><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202212011055372.png"></p><p>2）Observer：用来扩展查询节点，同时起到元数据备份的作用。如果在发现集群压力 </p><p>非常大的情况下，需要去扩展整个查询的能力，那么可以加 observer 的节点。observer 不 </p><p>参与任何的写入，只参与读取。 </p><p>⚫ <strong>BE<strong><strong>（</strong></strong>Backend****）</strong>：负责<strong>物理数据的存储和计算</strong>；依据 FE 生成的物理计划，分布式地执</p>]]></content>
      
      
      <categories>
          
          <category> Doris </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Doris </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装</title>
      <link href="/2022/11/18/mysql-an-zhuang/"/>
      <url>/2022/11/18/mysql-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/microtol/p/13863849.html">Linux 离线安装MySql 8.0.21教程</a></li><li><a href="https://blog.csdn.net/u012604745/article/details/80632860">阿里云使用问题</a></li></ul><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /varll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726170940.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> mysqlinstallll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726171503.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> mysqlinstallll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726171626.png"></p><h2 id="1、上传tar包并安装"><a href="#1、上传tar包并安装" class="headerlink" title="1、上传tar包并安装"></a>1、上传tar包并安装</h2><ul><li>上传mysql-8.0.21-1.el7.x86_64.rpm-bundle.tar到 mysqlinstall 下</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-vxf</span> mysql-8.0.21-1.el7.x86_64.rpm-bundle.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726171958.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum localinstall *.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726172112.png"></p><pre class="line-numbers language-none"><code class="language-none">Y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726172155.png"></p><h2 id="2、配置-x2F-etc-x2F-my-cnf"><a href="#2、配置-x2F-etc-x2F-my-cnf" class="headerlink" title="2、配置&#x2F;etc&#x2F;my.cnf"></a>2、配置&#x2F;etc&#x2F;my.cnf</h2><ul><li>如果不需要对数据库参数进行配置，服务的启动停止与状态命令如下</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start mysqld  systemctl status mysqldsystemctl stop mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726173115.png"></p><ul><li>假如要设置表名大小写不敏感 即 lower_case_table_names&#x3D;1</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#1.打开mysql配置文件</span><span class="token function">vim</span> /etc/my.cnf<span class="token comment">#2.在my.cnf文件的尾部追加一行</span><span class="token assign-left variable">lower_case_table_names</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment">#3.重启mysql</span>systemctl restart mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果不是在第一次启动mysql前配置得进行如下操作</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#A. 停止mysql</span>systemctl stop mysqld.service<span class="token comment">#B. 删除mysql的数据/var/lib/mysql（记得备份重要数据用于恢复）</span><span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/mysql<span class="token comment">#C. 再按照上面的方法1 2 3进行一遍操作即可。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、关闭防火墙"><a href="#3、关闭防火墙" class="headerlink" title="3、关闭防火墙"></a>3、关闭防火墙</h2><ul><li>根据需求关闭Linux的防火墙方便MYSQL Client连接</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status firewalldsystemctl stop firewalldsystemctl status firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726173448.png"></p><h2 id="4、保存临时密码"><a href="#4、保存临时密码" class="headerlink" title="4、保存临时密码"></a>4、保存临时密码</h2><ul><li>在第一次启动Mysql后会生成随机的临时密码供首次登陆试用，获取操作如下</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /var/log/mysqld.log <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"A temporary password"</span><span class="token comment">#获取保存好账户和临时密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726173714.png"></p><h2 id="5、修改密码"><a href="#5、修改密码" class="headerlink" title="5、修改密码"></a>5、修改密码</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql_secure_installation<span class="token comment">#修改密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726174201.png"></p><h2 id="6、Linux上登陆mysql"><a href="#6、Linux上登陆mysql" class="headerlink" title="6、Linux上登陆mysql"></a>6、Linux上登陆mysql</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726174339.png"></p><ul><li>以命令的方式降低mysql密码策略（服务重启可能失效，可在配置文件里配置永久）</li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW VARIABLES LIKE&#39;validate_password%&#39;;set global validate_password.policy&#x3D;LOW;SHOW VARIABLES LIKE&#39;validate_password%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726174620.png"></p><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726174737.png"></p><h2 id="7、创建用户、配置ip权限"><a href="#7、创建用户、配置ip权限" class="headerlink" title="7、创建用户、配置ip权限"></a>7、创建用户、配置ip权限</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 创建%连接的mysql账户CREATE USER&#39;mysqlm1&#39;@&#39;%&#39;IDENTIFIED BY&#39;rootroot;GRANT all privileges ON *.* TO&#39;mysqlm1&#39;@&#39;%&#39;;FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 将root账号设置Host为%use mysqlupdate user set host &#x3D; &#39;%&#39; where user &#x3D; &#39;root&#39;;FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726175044.png"></p><ul><li>查看表名忽略大小写是否成功设置为1 lower_case_table_names&#x3D;1则成功</li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show variables like ‘%low%’;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8、rpm安装的文件路径"><a href="#8、rpm安装的文件路径" class="headerlink" title="8、rpm安装的文件路径"></a>8、rpm安装的文件路径</h2><p><img src="https://picgobucket.oss-cn-shenzhen.aliyuncs.com/img/20210726175409.png"></p><h2 id="9、阿里云使用问题"><a href="#9、阿里云使用问题" class="headerlink" title="9、阿里云使用问题"></a>9、阿里云使用问题</h2><ul><li>将用户设置成无ip限制的host&#x3D;’%‘</li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">update user set host &#x3D; &#39;%&#39; where user &#x3D; &#39;root&#39;;FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>将用户的plugin设置为mysql_native_password</li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select host,user,plugin,authentication_string from mysql.user;ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="10、数据挂载-及-免密登录"><a href="#10、数据挂载-及-免密登录" class="headerlink" title="10、数据挂载 及 免密登录"></a>10、数据挂载 及 免密登录</h2><ul><li>配置文件参考</li></ul><pre class="line-numbers language-none"><code class="language-none">datadir&#x3D;&#x2F;data&#x2F;mysqldbsocket&#x3D;&#x2F;data&#x2F;mysqldb&#x2F;mysql.socklog-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.logpid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pidlower_case_table_names&#x3D;1sql_mode&#x3D;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTIONmax_connections&#x3D;1024server_id&#x3D;8081default-time-zone &#x3D; &#39;+08:00&#39;[client]host&#x3D;localhostuser&#x3D;&#39;root&#39;password&#x3D;&#39;ISd87-&#x2F;xs)hcw&#39;socket&#x3D;&#x2F;data&#x2F;mysqldb&#x2F;mysql.sock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
