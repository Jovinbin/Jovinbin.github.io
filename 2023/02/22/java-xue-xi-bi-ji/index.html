<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java学习笔记, Jovinbin">
    <meta name="description" content="一、基础1、 面向对象和面向过程的区别？
​	面向对象就是高度实物抽象化、面向过程就是自顶向下的编程！
​	面向过程：优点是性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。而Linux\Unix等一般采用面向过程开发，性">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java学习笔记 | Jovinbin</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Jovinbin</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Jovinbin</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Jovinbin" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Jovinbin" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">笔记</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-02-22
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    24.3k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><h4 id="1、-面向对象和面向过程的区别？"><a href="#1、-面向对象和面向过程的区别？" class="headerlink" title="1、 面向对象和面向过程的区别？"></a>1、 面向对象和面向过程的区别？</h4><blockquote>
<p>​	面向对象就是高度实物抽象化、面向过程就是自顶向下的编程！</p>
<p>​	<strong>面向过程</strong>：优点是性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。而Linux\Unix等一般采用面向过程开发，性能是最重要的因素。缺点是没有面向对象易维护，易复用，易扩展。可维护性差，不易修改。</p>
<p>​	<strong>面向对象</strong>：优点是易维护，易复用，易扩展。由于面向对象由封装，继承，多态性的特性，可以设计出耦合度低的系统，使系统更加灵活，更加易于维护。 缺点是性能比面向过程低。</p>
</blockquote>
<h4 id="2、关于JDK、JRE和JVM的看法？"><a href="#2、关于JDK、JRE和JVM的看法？" class="headerlink" title="2、关于JDK、JRE和JVM的看法？"></a>2、关于JDK、JRE和JVM的看法？</h4><blockquote>
<p>JDK包括Java虚拟机（JVM）、Java编译器（Javac）、Java归档文件（JAR）、Java文档（Javadoc）等。</p>
<p>JRE包括Java虚拟机（JVM）、运行时类库、执行Java字节码所需要的Java应用程序启动器，但省略了Java编译器等开发工具。</p>
<p>JDK包含了JRE，JRE包含了JDK。</p>
</blockquote>
<h4 id="3、字符型常量和字符串常量的区别？"><a href="#3、字符型常量和字符串常量的区别？" class="headerlink" title="3、字符型常量和字符串常量的区别？"></a>3、字符型常量和字符串常量的区别？</h4><blockquote>
<ul>
<li><p>形式不同：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符</p>
</li>
<li><p>含义上：字符常量相当于一个整型值(ASCII值)，可以参与表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置)</p>
</li>
<li><p>占内存大小：字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</p>
</li>
</ul>
</blockquote>
<h4 id="4、什么是字符串常量池？"><a href="#4、什么是字符串常量池？" class="headerlink" title="4、什么是字符串常量池？"></a>4、什么是字符串常量池？</h4><blockquote>
<p>​		字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p>
</blockquote>
<h4 id="5、构造器Constructor是否可被override？"><a href="#5、构造器Constructor是否可被override？" class="headerlink" title="5、构造器Constructor是否可被override？"></a>5、构造器Constructor是否可被override？</h4><p>不能被override（重写），但是可以被overload（重载）</p>
<p>Constructor 不能被继承, 所以不能被 override。</p>
<blockquote>
<p>构造器是用来干什么的：是用来生成一个类的实例，是用来初始化这个实例的。</p>
<p>构造器如何工作？</p>
<p>Java在构造实例时的顺序：</p>
<ul>
<li>分配对象空间，并将对象中成员初始化为零或空，Java不允许用户操纵一个不定值的对象</li>
<li>执行属性值的显式初始化</li>
<li>执行构造器</li>
<li>将变量关联到堆中的对象上</li>
</ul>
<p>而执行构造器的步骤又可以分为以下五步：</p>
<ul>
<li>分配参数给指定的构造函数</li>
<li>如果这个指定的构造函数的第一个语句使用this指针显示的调用本类的其他构造函数，则递归执行这5个步骤，如果执行过程正常则跳到步骤5</li>
<li>如果构造函数的第一个语句没有显式调用本类的其他构造函数，并且本类不是Object类（Object是所有类的父类，而它自己没有父类），则调用显式（super指针）或隐式的指定的父类的构造函数，递归执行这5个步骤，如果执行过程正常则跳到步骤5</li>
<li>执行这个构造函数中余下的语句，如果执行过程正常则过程结束</li>
</ul>
</blockquote>
<h4 id="6、重载和重写的区别？"><a href="#6、重载和重写的区别？" class="headerlink" title="6、重载和重写的区别？"></a>6、重载和重写的区别？</h4><blockquote>
<ul>
<li>定义不同：重载是定义相同的方法名，参数不同；重写是子类重写父类的方法</li>
<li>范围不同：重载是在一个类中；重写是子类与父类之间的</li>
<li>多态不同：重载是编译时的多态性；重写是运行时的多态性</li>
<li>返回不同：重载对返回类型没有要求；重写要求返回类型，有兼容的返回类型</li>
<li>参数不同：重载的参数个数、参数类型、参数顺序可以不同；重写父子方法参数必须相同</li>
<li>修饰不同：重载对访问修饰没有特殊要求；重写访问修饰符的限制一定要大于被重写的方法的访问修饰符</li>
</ul>
</blockquote>
<h4 id="7、Java面向对象编程三大特性：封装、继承、多态"><a href="#7、Java面向对象编程三大特性：封装、继承、多态" class="headerlink" title="7、Java面向对象编程三大特性：封装、继承、多态"></a>7、Java面向对象编程三大特性：封装、继承、多态</h4><blockquote>
<p><strong>封装</strong>：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p>
<p><strong>继承</strong>：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特 性的基础上进行扩展，增加新功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。<strong>继承主要解决的问题是：共性的抽取，实现代码复用。</strong></p>
<p><strong>多态</strong>：多态可以理解在继承的状态下，多个子类的行为都具有父类的行为特征，我们可以直接使用父类去指向子类对象，使父类对象可以指向不同的子类对象，调用方法时有多样的变化。</p>
</blockquote>
<h4 id="8、String、StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？"><a href="#8、String、StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="8、String、StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？"></a>8、String、StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？</h4><blockquote>
<p><strong>可变性</strong>：</p>
<ul>
<li>String内部实现其实是<code>private final char value[]</code>, 所以String对象是不可变的；</li>
<li>StringBuilder与StringBuffer都继承自AbstractStringBuilder类.AbstractStringBuilder是用<code>char[] value</code>来存储字符串的, 但是没有用final关键字, 所以StringBuilder和StringBuffer对象都是可变的</li>
</ul>
<p><strong>线程安全性</strong>：</p>
<ul>
<li>String中的对象是不可变的, 可以理解成常量, 是线程安全的；</li>
<li>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁, 所以是线程安全的</li>
<li>StringBuilder并没有对方法家同步锁, 所以是非线程安全的</li>
</ul>
<p><strong>性能</strong>：</p>
<ul>
<li>对于String对象而言, 每次都会生成一个新的String对象, 然后将指针指向新的String对象</li>
<li>StringBuffer和StringBuilder每次都会对对象本身进行操作, 而不是生成新的对象并且改变对象的引用. 相同情况下使用StringBuilder会比StringBuffer获得10%-15%的性能提升, 但是要承担多线程不安全的风险</li>
</ul>
<p>注：</p>
<ul>
<li>少量数据用String</li>
<li>单线程大量数据用StringBuilder</li>
<li>多线程大量数据用StringBuffer</li>
</ul>
</blockquote>
<h4 id="9、自动拆箱与装箱"><a href="#9、自动拆箱与装箱" class="headerlink" title="9、自动拆箱与装箱"></a>9、自动拆箱与装箱</h4><blockquote>
<p>int和Integer的区别</p>
<ul>
<li>Integer是int的包装类；int是基本数据类型；</li>
<li>Integer变量必须实例化后才能使用；int变量不需要；</li>
<li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li>
<li>Integer的默认值是null；int的默认值是0。</li>
</ul>
<p>jdk1.5 开始引入了自动装箱&#x2F;拆箱机制</p>
<ul>
<li><p><strong>自动装箱：将基本数据类型重新转化为对象</strong></p>
</li>
<li><p><strong>自动拆箱：将对象重新转化为基本数据类型</strong></p>
</li>
</ul>
</blockquote>
<h3 id="二、Java集合"><a href="#二、Java集合" class="headerlink" title="二、Java集合"></a>二、Java集合</h3><h4 id="1、说说List、Set、Map三者的区别？"><a href="#1、说说List、Set、Map三者的区别？" class="headerlink" title="1、说说List、Set、Map三者的区别？"></a>1、说说List、Set、Map三者的区别？</h4><blockquote>
<ul>
<li>List：是有序集合，可以存储重复的元素。List中的每一个元素都有一个对应的整数的索引，通过索引可以访问、插入、替换和删除元素。常用的List实现类有ArrayList和LinkedList。</li>
<li>Set：是无序集合，不可以存储重复元素。Set中的元素没有顺序，不能通过索引访问，但可以添加、查询、删除元素。常用的Set实现类有HashSet和TreeSet，其中 HashSet 基于哈希表实现，支持快速插入和查询操作；TreeSet 基于红黑树实现，支持有序集合操作，如查询最小值、最大值、前驱、后继等。</li>
<li>Map：是键值对集合，其中每个元素都是一个键值对。Map中的键是唯一的，但值可以重复。可以通过键来访问、插入、替换和删除对应的值。常用的Map实现类有HashMap和TreeMap，其中 HashMap 基于哈希表实现，支持快速插入和查询操作；TreeMap 基于红黑树实现，支持有序键值对操作，如查询最小键值对、最大键值对、前驱键值对、后继键值对等。</li>
</ul>
<p>三者的主要区别在于：有序&#x2F;无序、可重复&#x2F;不可重复、是否支持索引&#x2F;键值对等操作。</p>
</blockquote>
<h4 id="2、ArrayList和LinkedList的区别？"><a href="#2、ArrayList和LinkedList的区别？" class="headerlink" title="2、ArrayList和LinkedList的区别？"></a>2、ArrayList和LinkedList的区别？</h4><blockquote>
<ul>
<li><p>底层数据结构：</p>
<p>ArrayList基于动态数组实现，底层使用数组存储元素。数组的大小可以动态扩容，当数组容量不足时，会自动扩展数组的长度，以适应更多的元素。</p>
<p>LinkedList基于双向链表实现，底层使用链表存储元素。链表的每个节点包含元素值和指向下一个节点的指针。</p>
</li>
<li><p>插入和删除操作</p>
<p>由于 ArrayList 基于数组实现，插入和删除元素时需要移动后面的元素，因此在存储大量元素时，插入和删除操作的效率可能较低。而 LinkedList 基于链表实现，插入和删除元素时只需要修改节点的指针，因此在存储大量元素时，插入和删除操作的效率可能更高。</p>
</li>
<li><p>内存占用</p>
<p>ArrayList 和 LinkedList 的内存占用不同。由于 ArrayList 基于数组实现，所以它需要预分配一段连续的内存空间，因此在存储大量元素时，可能会浪费一些内存空间。而 LinkedList 不需要预分配连续的内存空间，每个元素都存储在单独的节点中，因此它可以更好地利用内存空间。</p>
</li>
<li><p>随机访问</p>
<p>由于 ArrayList 基于数组实现，它支持快速随机访问元素，即通过索引可以在 O(1) 的时间复杂度内访问元素。而 LinkedList 不支持随机访问，需要从头节点开始遍历链表，直到找到目标节点。</p>
</li>
</ul>
<p>综上所述，ArrayList 和 LinkedList 的选择取决于实际需求。如果需要快速随机访问元素，可以选择 ArrayList；如果需要频繁插入和删除元素，可以选择 LinkedList。</p>
</blockquote>
<h4 id="3、ArrayList和Vector区别？为什么要用ArrayList取代Vector呢？"><a href="#3、ArrayList和Vector区别？为什么要用ArrayList取代Vector呢？" class="headerlink" title="3、ArrayList和Vector区别？为什么要用ArrayList取代Vector呢？"></a>3、ArrayList和Vector区别？为什么要用ArrayList取代Vector呢？</h4><blockquote>
<ul>
<li><p>线程安全性</p>
<p>Vector是线程安全的，ArrayList是非线程安全的。</p>
</li>
<li><p>效率</p>
<p>ArrayList速度更快，没有进行额外的线程安全检查。</p>
</li>
</ul>
<p>目前，由于 Java 提供了更为高效的线程安全机制，如 ConccurentHashMap、ConcurrentSkipListMap 和 CopyOnWriteArrayList 等，所以在绝大多数情况下，使用 ArrayList 取代 Vector 是一个更好的选择。这也是为什么在 JDK 1.5 之后，Java 推荐使用 ArrayList，而不是 Vector。</p>
</blockquote>
<h4 id="4、说一说ArrayList的扩容机制？"><a href="#4、说一说ArrayList的扩容机制？" class="headerlink" title="4、说一说ArrayList的扩容机制？"></a>4、说一说ArrayList的扩容机制？</h4><blockquote>
<ul>
<li><p>初始容量</p>
<p>当创建一个新的ArrayList对象时，需要为其指定初始容量，如果没有指定，默认初始容量为10。</p>
</li>
<li><p>自动扩容</p>
<p>当向 ArrayList 中添加元素时，如果元素个数大于等于数组容量（也就是当前 ArrayList 的 size() 大于等于它的 capacity），就需要扩容。ArrayList 扩容的规则是，每次将当前数组容量增加1.5倍，同时将原数组中的元素复制到新数组中。这个过程会使用 System.arraycopy() 函数来进行数组的复制操作，这个操作时间复杂度为 O(n)。</p>
</li>
<li><p>指定初始容量</p>
<p>如果事先能够估算出 ArrayList 中元素的数量，可以在创建 ArrayList 对象时就指定一个足够大的初始容量，可以避免在添加元素时进行频繁的扩容操作，提高程序的效率。</p>
</li>
</ul>
<p>注意：需要注意的是，ArrayList 的扩容机制在处理大量数据时可能会带来一些性能问题，因为扩容操作需要重新分配更大的内存空间，并将原来的数据复制到新的内存空间中，这个过程可能会比较耗时。因此，在处理大量数据时，建议事先估算好数据量，并设置一个合适的初始容量，以减少扩容次数。</p>
</blockquote>
<h4 id="5、HashMap和HashTable的区别？"><a href="#5、HashMap和HashTable的区别？" class="headerlink" title="5、HashMap和HashTable的区别？"></a>5、HashMap和HashTable的区别？</h4><blockquote>
<ul>
<li><p>线程安全性</p>
<p>HashMap非线程安全，HashTable线程安全</p>
</li>
<li><p>null值处理</p>
<p>HashTable不允许key或value为空，否则会抛出空指针异常，HashMap可以允许key或value为空</p>
</li>
<li><p>初始容量和扩容机制</p>
<p>HashTable的初始容量默认为11，负载因子默认0.75。HashMap的初始容量默认为16，负载因子默认为0.75。当哈希表中的元素数量超过了负载因子和容量的乘积时，就会自动扩容</p>
</li>
<li><p>性能</p>
<p>HashTable的方法被synchronized 关键字修饰，会带来一定的性能开销。比HashMap慢</p>
</li>
</ul>
</blockquote>
<h4 id="6、HashSet如何检查重复？"><a href="#6、HashSet如何检查重复？" class="headerlink" title="6、HashSet如何检查重复？"></a>6、HashSet如何检查重复？</h4><blockquote>
<p>HashSet是Java中的一种集合类，底层是基于HashMap实现的。在HashSet中，元素是无序的、不可重复的。</p>
<p>HashSet是通过对元素进行哈希操作来判断是否重复的。当我们向HashSet中添加一个元素时，HashSet会首先计算该元素的哈希码（hash code），然后将哈希码作为key，将元素本身作为value，将其存储到底层的HashMap中。如果在添加新元素时发现该元素的哈希码已经在HashMap中存在，那么HashSet会比较新元素和已有元素的equals方法返回值是否为true，如果是，则认为新元素重复了，不再添加到集合中。</p>
</blockquote>
<h4 id="7、HashMap的底层实现？"><a href="#7、HashMap的底层实现？" class="headerlink" title="7、HashMap的底层实现？"></a>7、HashMap的底层实现？</h4><blockquote>
<p>Java中的HashMap是一种基于哈希表实现的键值对（key-value）映射数据结构，它使用哈希函数将key映射到数组中的位置，从而实现快速的插入、删除和查找操作。</p>
<p>HashMap的底层实现是一个数组（table），数组中的每个元素是一个链表或红黑树（JDK1.8及以上版本），用于存储相同哈希值的key-value对。在JDK1.8之前，如果同一个哈希值的key-value对的数量超过了一个阈值（默认为8），就会将这些元素存储在一个链表中，而JDK1.8及以上版本引入了红黑树来优化这种情况，提高了查找效率。</p>
<p>需要注意的是，HashMap的实现不是线程安全的，如果在多线程环境中使用HashMap，需要采取相应的措施来保证线程安全，例如使用ConcurrentHashMap，或者使用锁来保护HashMap的操作。</p>
</blockquote>
<h4 id="8、HashMap多线程的操作导致死循环问题？"><a href="#8、HashMap多线程的操作导致死循环问题？" class="headerlink" title="8、HashMap多线程的操作导致死循环问题？"></a>8、HashMap多线程的操作导致死循环问题？</h4><blockquote>
<p>在多线程环境下，如果对HashMap进行不当的操作，可能会导致HashMap的内部数据结构发生破坏，从而导致死循环或其他问题。</p>
<p>具体来说，如果多个线程同时对HashMap进行修改操作，例如put或remove，可能会导致其中一个线程正在执行的操作影响到其他线程，从而导致内部数据结构的破坏。例如，如果多个线程同时对同一个桶（bucket）进行操作，可能会导致链表中的元素出现断裂，从而导致死循环等问题。</p>
<p>另外，由于HashMap不是线程安全的，如果在多线程环境中同时进行读写操作，也可能会导致数据不一致的问题，例如读取到过时的数据或者写入失败等。</p>
<p>为了避免这些问题，可以采取以下几种措施：</p>
<ul>
<li>使用线程安全的Map实现，例如ConcurrentHashMap，这些实现使用了锁机制或其他并发控制手段，可以保证多线程环境下的安全访问；</li>
<li>在多线程环境下使用synchronized或者Lock等同步机制来保护HashMap的访问；</li>
<li>在多线程环境下只进行读取操作，避免对HashMap进行写操作；</li>
<li>在多线程环境下对HashMap进行分段或分片，使得每个线程只对特定的区域进行操作，从而避免竞争和冲突。</li>
</ul>
</blockquote>
<h4 id="9、ConcurrentHashMap和HashTable的区别？"><a href="#9、ConcurrentHashMap和HashTable的区别？" class="headerlink" title="9、ConcurrentHashMap和HashTable的区别？"></a>9、ConcurrentHashMap和HashTable的区别？</h4><blockquote>
<ul>
<li><p>同步机制的不同</p>
<p>HashTable使用synchronized关键字对整个Hashtable对象进行同步，即每个线程访问Hashtable时都需要获取对象级别的锁，这会影响并发性能。而ConcurrentHashMap使用了分段锁的机制，将Map分成多个Segment（段），每个Segment都是一个独立的HashTable，只对Segment进行加锁，这样多个线程可以同时访问不同的Segment，从而提高并发性能。</p>
</li>
<li><p>扩容机制的不同</p>
<p>HashTable在进行扩容时会将整个HashTable锁住，这样在扩容期间其他线程无法访问HashTable，从而影响并发性能。而ConcurrentHashMap可以进行动态扩容，并且不会锁住整个Map，只需要对正在扩容的Segment加锁，其他Segment仍然可以被并发访问。</p>
</li>
<li><p>空值的支持</p>
<p>HashTable不支持null值作为key或value，任何null值的插入都会抛出NullPointerException异常。而ConcurrentHashMap可以支持null值作为key或value。</p>
</li>
<li><p>遍历方式的不同</p>
<p>Hashtable的遍历方式是Enumeration，而ConcurrentHashMap是通过Iterator或者forEach进行遍历。</p>
</li>
<li><p>性能的不同</p>
<p>由于ConcurrentHashMap使用了分段锁的机制，可以在多线程并发访问时提高并发性能，因此通常比HashTable具有更好的性能。</p>
</li>
</ul>
</blockquote>
<h4 id="10、ConcurrentHashMap线程安全的具体实现方式-x2F-底层具体实现？"><a href="#10、ConcurrentHashMap线程安全的具体实现方式-x2F-底层具体实现？" class="headerlink" title="10、ConcurrentHashMap线程安全的具体实现方式&#x2F;底层具体实现？"></a>10、ConcurrentHashMap线程安全的具体实现方式&#x2F;底层具体实现？</h4><blockquote>
<ul>
<li><p>分段锁机制：ConcurrentHashMap内部将Map划分为一定数量的Segment（段），每个Segment维护一个散列表。在默认情况下，ConcurrentHashMap会根据CPU的核数来确定Segment的数量。不同线程对不同Segment的访问是互相独立的，因此可以提高并发访问性能。</p>
</li>
<li><p>CAS（Compare and Swap）机制：ConcurrentHashMap在并发修改Map的过程中，使用CAS操作来保证数据的一致性和线程安全。CAS操作可以避免使用锁机制带来的性能损失，并且可以保证数据的一致性。</p>
</li>
</ul>
<p>具体来说，ConcurrentHashMap中每个Segment内部使用ReentrantLock（可重入锁）来保证线程安全，在修改数据时获取Segment对应的锁。而在查询数据时，ConcurrentHashMap可以同时访问所有Segment中的数据，因此可以提高查询性能。</p>
<p>在具体实现中，ConcurrentHashMap还使用了volatile关键字、Unsafe类等技术来确保数据的可见性和操作的原子性。同时，为了避免死锁的发生，ConcurrentHashMap在内部使用了一个”死亡节点”（Dead Node）来处理锁的释放。</p>
<p>总的来说，ConcurrentHashMap的线程安全是通过分段锁机制和CAS机制相结合来实现的，这种机制可以在保证线程安全的同时提高并发访问性能，是Java并发编程中常用的高性能数据结构之一。</p>
</blockquote>
<h4 id="11、Comparable和Comparator的区别"><a href="#11、Comparable和Comparator的区别" class="headerlink" title="11、Comparable和Comparator的区别"></a>11、Comparable和Comparator的区别</h4><blockquote>
<p>Comparable是Java内置的接口，它在类内部实现，允许在一个类中实现自然排序。一个类实现了Comparable接口后，就可以使用Arrays.sort()和Collections.sort()等排序方法对类的实例进行排序。当然，需要注意的是，使用Comparable进行排序时，只能进行一种排序方式。</p>
<p>Comparator接口是Java提供的用于定义排序顺序的一种方法。Comparator允许在单独的类中定义排序顺序，这样可以对多个类进行同一种排序。Comparator接口有一个方法：compare(Object o1, Object o2)，该方法返回一个整数值，如果o1小于o2，返回负数；如果o1等于o2，返回0；如果o1大于o2，返回正数。与Comparable不同的是，Comparator可以实现多种排序方式，因此我们可以通过实现不同的Comparator来对同一个类的实例进行不同的排序。</p>
<p>Comparable接口的实现是固定的，无法在运行时修改。而Comparator接口的实现是灵活的，可以在运行时根据需要创建多个比较器对象来对不同的对象进行排序。</p>
</blockquote>
<h3 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h3><h4 id="1、什么是多线程？"><a href="#1、什么是多线程？" class="headerlink" title="1、什么是多线程？"></a>1、什么是多线程？</h4><blockquote>
<p>在Java中，多线程是指在同一时间内，有多个线程在并发的执行代码。每个线程都拥有自己的执行堆栈和程序计数器，并且可以独立的执行。多线程编程允许我们同时处理多个任务，从而提高程序的执行效率和影响力。</p>
</blockquote>
<h4 id="2、请简要描述线程与进程的关系，区别及优点？"><a href="#2、请简要描述线程与进程的关系，区别及优点？" class="headerlink" title="2、请简要描述线程与进程的关系，区别及优点？"></a>2、请简要描述线程与进程的关系，区别及优点？</h4><blockquote>
<p>线程和进程都是操作系统中用于并发执行程序的概念。</p>
<p>进程是一个正在执行中的程序实例。它拥有自己的地址空间、内存、文件句柄和其他系统资源。每个进程都有一个唯一的进程标识符（PID）。在操作系统中，进程是资源分配和调度的基本单位。</p>
<p>线程是进程中的执行单元。一个进程可以包含多个线程，这些线程共享同一个地址空间、内存和其他系统资源。每个线程有自己的执行堆栈和程序计数器，但共享同一个进程的堆空间。在操作系统中，线程是调度的基本单位，它比进程更轻量级，创建和销毁线程的代价也更小。</p>
<p>区别：</p>
<ul>
<li>进程是操作系统资源分配的最小单位，而线程是进程中执行的最小单位。</li>
<li>进程之间相互独立，互不干扰，而线程之间共享进程的资源，彼此之间可以互相通信和协作。</li>
<li>进程拥有独立的地址空间，而线程共享进程的地址空间。</li>
<li>进程之间切换的开销比线程之间的开销大得多，进程间通信的代价也比线程间通信的代价大。</li>
</ul>
<p>优点：</p>
<ul>
<li>多进程可以更好地利用多核CPU的计算能力，提高程序的并行性和吞吐量；</li>
<li>多线程可以减少创建和销毁线程的开销，同时也可以更好地利用单核CPU的计算能力，提高程序的响应速度和效率。</li>
</ul>
</blockquote>
<h4 id="3、说说并发与并行的区别？"><a href="#3、说说并发与并行的区别？" class="headerlink" title="3、说说并发与并行的区别？"></a>3、说说并发与并行的区别？</h4><blockquote>
<p>并发（concurrency）指的是在同一时间段内，有多个任务在交替地执行。这些任务可能在同一个进程中，也可能在不同的进程中。在并发执行的任务中，它们的执行是相互独立的，彼此之间没有直接的影响，但是它们可能会共享同一些资源（如内存、文件等），这就需要进行资源共享和同步。</p>
<p>并行（parallelism）指的是在同一时间段内，有多个任务同时执行。这些任务可以在多个CPU、多核处理器或者多台计算机上并行执行，相互之间不会有任何干扰。在并行执行的任务中，它们的执行是同时进行的，不需要进行资源共享和同步。</p>
<p>区别：</p>
<ul>
<li><p>并发和并行都是在同一时间段内执行多个任务，但是并发是交替执行的，而并行是同时执行的。</p>
</li>
<li><p>并发通常是在单个CPU上实现的，通过时间分片的方式来交替执行多个任务，而并行是在多个CPU或多核CPU上实现的。</p>
</li>
<li><p>并发需要进行资源共享和同步，因为多个任务可能会共享同一些资源，而并行不需要进行资源共享和同步。</p>
</li>
</ul>
</blockquote>
<h4 id="4、为什么要使用多线程呢？"><a href="#4、为什么要使用多线程呢？" class="headerlink" title="4、为什么要使用多线程呢？"></a>4、为什么要使用多线程呢？</h4><blockquote>
<ul>
<li>提高程序的响应速度</li>
<li>提高程序的性能</li>
<li>提高资源利用率</li>
<li>改善用户体验</li>
</ul>
</blockquote>
<h4 id="5、使用多线程可能带来什么问题？"><a href="#5、使用多线程可能带来什么问题？" class="headerlink" title="5、使用多线程可能带来什么问题？"></a>5、使用多线程可能带来什么问题？</h4><blockquote>
<ul>
<li><p>线程安全问题：由于多个线程访问共享资源，可能会导致数据的不一致性或者丢失。这需要使用同步机制来保证线程安全。</p>
</li>
<li><p>死锁问题：当多个线程相互等待对方释放资源的时候，可能会导致死锁，从而导致程序无法继续执行。这需要使用正确的锁机制来避免死锁问题。</p>
</li>
<li><p>上下文切换问题：由于CPU需要在多个线程之间切换执行，这会导致一定的时间开销。如果线程数量过多，会导致上下文切换的开销过大，影响程序的性能。</p>
</li>
<li><p>资源竞争问题：由于多个线程可能同时竞争一些资源，如文件、网络连接、数据库连接等，可能会导致资源的浪费或者瓶颈。这需要使用正确的资源管理和调度机制来避免资源竞争问题。</p>
</li>
<li><p>线程阻塞问题：当一个线程因为某个资源而阻塞时，会导致程序的响应速度变慢。这需要使用异步编程技术来避免线程阻塞问题。</p>
</li>
</ul>
</blockquote>
<h4 id="6、说说线程的生命周期和状态？"><a href="#6、说说线程的生命周期和状态？" class="headerlink" title="6、说说线程的生命周期和状态？"></a>6、说说线程的生命周期和状态？</h4><blockquote>
<p>线程的生命周期可以分为五个状态：新建、就绪、运行、阻塞、死亡。</p>
<ol>
<li>新建状态：当线程对象被创建时，线程处于新建状态。此时线程并没有启动，它只是一个Java对象。</li>
<li>就绪状态：当线程调用 start() 方法后，线程处于就绪状态。此时线程已经被系统分配到了CPU资源，但是还没有开始执行。</li>
<li>运行状态：当线程获得CPU时间片并开始执行时，线程处于运行状态。此时线程正在执行代码。</li>
<li>阻塞状态：当线程因为某些原因不能执行时，线程处于阻塞状态。例如，线程等待某个输入、输出操作完成、请求某个锁、等待某个条件满足等。在这种状态下，线程不会占用CPU时间，直到它被唤醒。</li>
<li>终止状态：当线程完成了它的任务或者出现了异常时，线程处于终止状态。此时线程不再执行，也不占用CPU时间。</li>
</ol>
</blockquote>
<h4 id="7、什么是线程死锁？如何避免死锁？"><a href="#7、什么是线程死锁？如何避免死锁？" class="headerlink" title="7、什么是线程死锁？如何避免死锁？"></a>7、什么是线程死锁？如何避免死锁？</h4><blockquote>
<p>线程死锁是指两个或多个线程在互相等待对方释放锁时，形成了一种僵局，导致线程无法继续执行。一般来说，线程死锁的发生是由于以下四个必要条件同时满足造成的：</p>
<ol>
<li>互斥条件：资源只能被同一个线程占用，如果一个线程已经占用了资源，其他线程就必须等待该线程释放资源。</li>
<li>请求与保持条件：一个线程持有某个资源的同时，又请求获取其他资源，而这些资源可能正被其他线程占用。</li>
<li>不剥夺条件：资源只能由占用它的线程释放，其他线程无法强制占用该资源。</li>
<li>循环等待条件：若干线程之间形成一种循环等待资源的关系，形成闭环，导致线程无法继续执行。</li>
</ol>
<p>为了避免线程死锁，我们可以采用以下几种策略：</p>
<ol>
<li>避免使用多个锁：如果每个线程只需要一个锁，那么死锁的概率就会大大降低。如果必须使用多个锁，可以按照一定的顺序获取锁，从而避免死锁。</li>
<li>及时释放锁：当线程使用完共享资源后，应该及时释放锁，避免占用锁的时间过长，导致其他线程长时间等待。</li>
<li>死锁检测：可以使用一些工具或算法来检测死锁的发生，并及时采取措施来避免死锁的发生。</li>
<li>破坏循环等待条件：可以采用一些方法来破坏循环等待条件，例如按序申请资源、限制资源申请次数、强制释放资源等。</li>
</ol>
</blockquote>
<h4 id="8、说说sleep-方法和wait-方法区别和共同点？"><a href="#8、说说sleep-方法和wait-方法区别和共同点？" class="headerlink" title="8、说说sleep()方法和wait()方法区别和共同点？"></a>8、说说sleep()方法和wait()方法区别和共同点？</h4><blockquote>
<p>区别：</p>
<ol>
<li>sleep()方法和wait()方法的使用对象不同。sleep()方法是Thread类的静态方法，可以直接使用，而wait()方法是Object类的实例方法，只能在synchronized代码块中使用。</li>
<li>sleep()方法是线程休眠一段时间后继续执行，不会释放持有锁。wait()方法会让线程暂时释放持有的锁并进入等待队列，知道被唤醒后才会重新竞争锁。</li>
<li>sleep()方法可以在任何地方使用，而wait()方法必须在同步块中使用，因为wait()方法需要先获取对象的监视器才能等待和被唤醒。</li>
</ol>
<p>共同点：</p>
<ol>
<li>sleep()方法和wait()方法都可以用于线程的暂停和唤醒。</li>
<li>sleep()方法和wait()方法都会抛出InterruptedException异常，当线程在等待或睡眠状态中被中断时抛出。</li>
<li>sleep()方法和wait()方法都需要指定等待时间，sleep()方法指定的是休眠时间，wait()方法指定的是等待时间。</li>
<li>sleep()方法和wait()方法都会使线程进入阻塞状态。</li>
</ol>
</blockquote>
<h4 id="9、为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用-run-方法？"><a href="#9、为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="9、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用.run()方法？"></a>9、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用.run()方法？</h4><blockquote>
<p>在Java中，当我们创建一个线程并调用它的start()方法时，系统会在新线程中执行run()方法。这是因为start()方法会为新线程分配资源并启动它，使其进入就绪状态，并开始执行run()方法。这个过程需要操作系统和Java虚拟机的配合完成，包括为新线程分配栈空间、保存线程上下文等操作。</p>
<p>相反，如果我们直接调用run()方法，这只是普通的方法调用，并不会启动一个新的线程。run()方法将在当前线程中执行，而不是在新的线程中执行。也就是说，线程并没有并发执行，而是顺序执行了run()方法。这种情况与创建一个新线程的目的相悖，因为我们通常创建线程是为了并发执行任务，以提高程序的效率和性能。如果我们直接调用run()方法，就无法实现这个目的。</p>
<p>因此，正确的方式是通过调用start()方法来启动一个新线程，并在新线程中执行run()方法，从而实现多线程并发执行的目的。</p>
</blockquote>
<h4 id="10、说一说自己对synchronized关键字的了解"><a href="#10、说一说自己对synchronized关键字的了解" class="headerlink" title="10、说一说自己对synchronized关键字的了解"></a>10、说一说自己对synchronized关键字的了解</h4><blockquote>
<p>synchronized是Java中的一个关键字，用于保护共享资源并确保多线程下的安全性。当多个线程需要访问同一共享资源时，使用synchronized关键字可以防止出现竟态条件，从而避免数据的不一致性和线程安全问题。</p>
<p>具体来说，synchronized关键字可以作用于以下两个方面：</p>
<ol>
<li>同步方法：可以将synchronized关键字应用于整个方法上，表示该方法为同步方法。当一个线程进入同步方法时，他会获取该方法所属对象的锁，其他线程将会被阻塞，直到当前线程释放锁。</li>
<li>同步代码块：可以将synchronized关键字应用于某个代码块上，表示该代码块为同步代码块。同步代码块的锁对象可以是任何一个对象，包括this对象。当一个线程进入同步代码块时，它会获取该锁对象的锁，其他线程将会被阻塞，直到当前线程释放锁。</li>
</ol>
<p>synchronized关键字的使用可以有效地保护共享资源并确保线程安全，但是也有一些注意点：</p>
<ol>
<li>synchronized关键字会降低程序的性能，因为多个线程在获取锁时可能会发生竞争和阻塞。</li>
<li>需要注意死锁的情况，即两个或多个线程相互等待对方释放锁而无法继续执行的情况。为避免死锁，应该避免在同步块中嵌套同步块，或者在同步块中调用其他对象的同步方法。</li>
<li>在使用synchronized关键字时，应该遵循同步代码块越小越好的原则，以减少锁的竞争和阻塞，提高程序的并发性能。</li>
</ol>
</blockquote>
<h4 id="11、什么是上下文切换"><a href="#11、什么是上下文切换" class="headerlink" title="11、什么是上下文切换"></a>11、什么是上下文切换</h4><blockquote>
<p>在多线程环境下，线程是操作系统调度的最小单位，而上下文切换也是在线程之间进行的。当操作系统需要切换线程时，它会保存当前线程的上下文信息，包括线程的程序计数器、栈指针、寄存器值、线程状态等，并将这些信息保存到内存中。然后，操作系统会从就绪队列中选择另一个线程并恢复其上下文信息，CPU继续执行新的线程。这个过程就是多线程的上下文切换。</p>
<p>与单线程的上下文切换相比，多线程的上下文切换需要保存和恢复更多的上下文信息，因为每个线程都有自己的程序计数器、栈、寄存器等，而且它们共享进程的地址空间和系统资源。因此，多线程的上下文切换通常比单线程的上下文切换更耗费时间和系统资源，尤其是在高并发的多线程应用中。</p>
<p>为了避免过多的上下文切换，可以采用以下策略：</p>
<ol>
<li>使用线程池来重复使用线程，避免频繁创建和销毁线程。</li>
<li>减少锁的竞争，避免线程之间的等待，以减少上下文切换的次数。</li>
<li>使用非阻塞式I&#x2F;O操作，避免线程的I&#x2F;O等待时间，以提高并发性能。</li>
<li>使用适当的调度算法，如先来先服务、时间片轮转、优先级调度等，以最大限度地减少上下文切换的次数。</li>
</ol>
</blockquote>
<h3 id="四、线程池"><a href="#四、线程池" class="headerlink" title="四、线程池"></a>四、线程池</h3><h4 id="1、什么是线程池？"><a href="#1、什么是线程池？" class="headerlink" title="1、什么是线程池？"></a>1、什么是线程池？</h4><blockquote>
<p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
</blockquote>
<h4 id="2、为什么要用线程池？"><a href="#2、为什么要用线程池？" class="headerlink" title="2、为什么要用线程池？"></a>2、为什么要用线程池？</h4><blockquote>
<ul>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁的消耗。</li>
<li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性：无限制的创建线程，不仅会消耗系统的资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
</blockquote>
<h4 id="3、如何创建线程池？"><a href="#3、如何创建线程池？" class="headerlink" title="3、如何创建线程池？"></a>3、如何创建线程池？</h4><blockquote>
<ul>
<li><p>通过<code>ThreadPoolExecutor</code>构造函数创建（推荐）;</p>
</li>
<li><p>通过<code>Executor</code>框架的工具类<code>Executor</code>来创建</p>
<ul>
<li><p><strong><code>FixedThreadPool</code></strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
<p><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p>
<p><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p>
<p><strong><code>ScheduledThreadPool</code></strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4、线程池常见参数有哪些？如何解释？"><a href="#4、线程池常见参数有哪些？如何解释？" class="headerlink" title="4、线程池常见参数有哪些？如何解释？"></a>4、线程池常见参数有哪些？如何解释？</h4><blockquote>
<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><code>corePoolSize</code>（核心线程数）：任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li><code>maxPoolSize</code>（最大线程数）：任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><code>queueCapacity</code>（消息队列数量）：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ul>
<li><code>keepAliveSeconds</code>（存活时间）：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><code>rejectedExecutionHandler</code>（拒绝策略）<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>： 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>： 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：*不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="5、线程池处理任务的流程？"><a href="#5、线程池处理任务的流程？" class="headerlink" title="5、线程池处理任务的流程？"></a>5、线程池处理任务的流程？</h4><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202302231553018.png" alt="image-20230223155345913"></p>
<ul>
<li>如果当前运行的线程数小于核心线程数，那么就会创建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，那么就把该任务放入到任务队列里等待执行。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数量是小于最大线程数的，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ul>
<h3 id="五、JVM"><a href="#五、JVM" class="headerlink" title="五、JVM"></a>五、JVM</h3><h4 id="1、介绍下Java内存区域（运行时数据区）"><a href="#1、介绍下Java内存区域（运行时数据区）" class="headerlink" title="1、介绍下Java内存区域（运行时数据区）"></a>1、介绍下Java内存区域（运行时数据区）</h4><blockquote>
<p>Java内存区域（运行时数据区）是指在Java虚拟机中用来存储程序执行期间的数据的区域，Java虚拟机规范将其划分为以下五个区域：</p>
<ol>
<li>程序计数器：是一块较小的内存区域，用于指示JVM正在执行的字节码指令的地址。由于Java虚拟机采用的是线程轮流切换执行的方式，因此每个线程都要有一个独立的程序计数器，各个线程之间互不干扰，独立存储，这也是为什么Java虚拟机规范中把程序计数器定义为线程私有的原因。</li>
<li>Java虚拟机栈：Java虚拟机栈是线程私有的，它描述的是Java方法执行的内存模型，而每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、</li>
<li>操作数栈、动态链接、方法出口等信息。当方法执行完毕时，栈帧被销毁，这个过程对应着方法的出栈（pop）操作。</li>
<li>堆（Heap）：堆是 Java 虚拟机中最大的一块内存区域，也是所有线程共享的一块内存区域。在虚拟机启动时就已经创建，用于存储对象实例和数组，几乎所有的对象实例都在这里分配内存。堆的大小可以通过 -Xmx 和 -Xms 参数来指定，如果堆中没有足够的空间进行对象分配，则会触发垃圾回收（GC）。</li>
<li>方法区（Method Area）：方法区也是所有线程共享的一块内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码等数据。虽然方法区也被称为永久代（Permanent Generation），但是在 JDK 8 中已经被彻底移除，用元空间（Metaspace）代替了永久代的实现。</li>
<li>运行时常量池（Runtime Constant Pool）：运行时常量池是方法区的一部分，用于存储编译期间生成的字面量和符号引用，这些内容在类加载后会被放到运行时常量池中。在运行期间，如果需要使用常量池中的内容，就直接从运行时常量池中取出即可。</li>
</ol>
<p>除了以上五个区域，Java虚拟机中还有直接内存和本地方法栈。</p>
</blockquote>
<h4 id="2、说一下Java对象的创建过程"><a href="#2、说一下Java对象的创建过程" class="headerlink" title="2、说一下Java对象的创建过程"></a>2、说一下Java对象的创建过程</h4><blockquote>
<ol>
<li>类加载：在Java程序运行时，Java虚拟机首先要加载对象所属的类。这个过程中，Java虚拟机会在类路径下搜索并找到对象所属的类文件，并将其加载到内存中。</li>
<li>分配内存：在类加载完成后，Java虚拟机会为对象分配内存。Java对象在内存中的分配时通过“new”关键字实现的，这时候Java虚拟机会为对象分配足够的内存空间，以存储对象的成员变量。</li>
<li>初始化：内存分配完成后，Java虚拟机会自动为对象的成员变量附默认值，例如int类型的成员变量会被赋值为0，引用类型的成员变量会被赋值为null。如果对象的类中定义了构造函数，Java虚拟机会调用构造函数堆成员变量进行初始化。</li>
<li>设置对象的引用：Java虚拟机在创建对象的同时，还会在堆中为该对象分配一个唯一的引用值。这个引用值被赋值给对象的引用变量，这样程序就可以通过引用变量来操作对象了。</li>
<li>返回对象的引用：在对象创建完成后，Java虚拟机会返回对象的引用给程序。程序可以通过这个引用来访问对象成员变量和方法。</li>
</ol>
</blockquote>
<h4 id="3、对象的访问定位有哪两种方式"><a href="#3、对象的访问定位有哪两种方式" class="headerlink" title="3、对象的访问定位有哪两种方式"></a>3、对象的访问定位有哪两种方式</h4><blockquote>
<ol>
<li>引用变量：程序可以通过引用变量来访问对象的成员变量和方法。在Java中，每个对象都有唯一的引用值，这个引用值被赋值给对象的引用变量，通过引用变量就可以访问对象的成员变量和方法。</li>
<li>对象的this指针：在Java中，每一个对象都有一个隐含的this指针，代表对象本身。this指针可以在对象内部使用，用来访问对象的成员变量和方法。例如，在一个类的方法中，可以通过this指针来访问该对象的成员变量和方法。</li>
</ol>
</blockquote>
<h4 id="4、说一下堆内存中对象的分配的基本策略"><a href="#4、说一下堆内存中对象的分配的基本策略" class="headerlink" title="4、说一下堆内存中对象的分配的基本策略"></a>4、说一下堆内存中对象的分配的基本策略</h4><blockquote>
<ol>
<li>标记-清楚算法：是一种基本的垃圾回收算法。在这种算法中，首先会扫描堆中的所有对象，将存活的对象打上标记，然后将未标记的对象视为垃圾，进行清除。这种算法的缺点是会产生大量的存储碎片，从而导致内存空间的利用率降低。</li>
<li>分代收集算法：分代收集算法是一种更加高效的垃圾回收算法。在这种算法中，Java堆被划分为新生代和老年代两个部分。新生代中的对象一般存活时间比较短，因此使用复制算法进行垃圾回收；而老年代中的对象一般存活时间比较长，因此使用标记-清除算法或标记-整理算法进行垃圾回收。这种算法的优点是可以有效地减少内存碎片，提高内存空间的利用率。</li>
</ol>
</blockquote>
<h4 id="5、Minor-GC和Full-GC有什么不同"><a href="#5、Minor-GC和Full-GC有什么不同" class="headerlink" title="5、Minor GC和Full GC有什么不同"></a>5、Minor GC和Full GC有什么不同</h4><blockquote>
<p>在Java中，垃圾收集（GC）时自动进行的，主要用于释放不再使用的内存空间。垃圾收集器主要分为Minor GC和Full GC两种，它们的不同点如下：</p>
<ol>
<li>触发时机不同：Minor GC发生在新生代，用于回收新生代中不再使用的对象，而Full GC发生在老年代，用于回收老年代中不再使用的对象。</li>
<li>回收的对象不同：Minor GC主要回收新生代中的对象，它会将存活的对象复制到另一个空间中，然后清空整个新生代空间。Full GC主要回收老年代中的对象，以及在新生代中晋升到老年代的对象。</li>
<li>垃圾收集时间不同：Minor GC的触发频率比较高，一般来说时间很短，一般不会造成系统停顿。Full GC的出发频率比较低，一般需要一定的时间来完成垃圾回收操作，可能会导致系统暂停或停顿。</li>
<li>内存回收效率不同：Minor GC只需要回收新生代对象，内存回收效率比较高，而Full GC需要回收整个堆空间中的对象，内存回收率比较低。</li>
</ol>
<p>综上所述，Minor GC和Full GC是两种不同的垃圾收集器，他们的触发时机、回收对象、垃圾收集时间和内存回收率都有所不同。</p>
</blockquote>
<h4 id="6、如何判断对象是否死亡？（两种方法）"><a href="#6、如何判断对象是否死亡？（两种方法）" class="headerlink" title="6、如何判断对象是否死亡？（两种方法）"></a>6、如何判断对象是否死亡？（两种方法）</h4><blockquote>
<ol>
<li>引用计数法：引用计数法是一种常见的判断对象是否死亡的方法。在这种方法中，每个对象都有一个引用计数器，用于统计当前有多少个对象引用该对象。当对象的引用计数器为0时，说明该对象不再被引用，可以被垃圾回收器回收。但是这种方法存在一个问题，就是很难解决循环引用的问题，即A对象引用B对象，而B对象又引用A对象，导致引用计数器都不为0，从而导致内存泄漏。</li>
<li>可达性分析法：可达性分析法是Java中常用的判断对象是否死亡的方法。在这种方法中，通过一系列称为”GC Roots”的根对象作为起点，从这些根对象开始向下搜索，搜索过程中遇到的对象都被标记为存活对象，未搜索到的对象则被标记为可回收对象。这种方法的优点是可以有效解决循环引用的问题，同时也可以准确地判断对象是否死亡。Java中的垃圾回收器就是基于可达性分析法实现的。</li>
</ol>
</blockquote>
<h4 id="7、如何判断一个常量是否时废弃常量？"><a href="#7、如何判断一个常量是否时废弃常量？" class="headerlink" title="7、如何判断一个常量是否时废弃常量？"></a>7、如何判断一个常量是否时废弃常量？</h4><blockquote>
<p>在Java中，如果一个常量不再被任何程序引用，那么就可以被认为是废弃常量，可以被垃圾回收器回收。判断常量是否废弃常量，可以使用工具类jmap和jhat。</p>
<p>具体步骤如下：</p>
<ol>
<li>使用jmap命令生成Java进程的内存转储文件：jmap -dump:live,format&#x3D;b,file&#x3D;heap.bin <pid></li>
<li>使用jhat命令将内存转储文件转换成可视化的HTML页面：jhat heap.bin</li>
<li>打开生成的HTML页面，在左侧导航栏中选择”Sites”，然后在”Show unreachable objects”中选择”true”，即可查看所有废弃对象。</li>
<li>在页面中选择”Constant Pools”，可以查看所有的常量池，包括String常量池、Class常量池等。废弃常量往往会存在于常量池中。</li>
<li>可以通过查看常量池中的引用数来判断常量是否废弃。如果一个常量没有被任何对象引用，那么它的引用数应该为0，可以通过查看常量池中每个常量的引用数来确定是否废弃常量。</li>
</ol>
<p>需要注意的是，判断常量是否废弃常量需要使用jmap和jhat等工具类，这些工具类仅在开发和测试环境下使用，不应在生产环境中使用。</p>
</blockquote>
<h4 id="8、如何判断一个类是无用的类？"><a href="#8、如何判断一个类是无用的类？" class="headerlink" title="8、如何判断一个类是无用的类？"></a>8、如何判断一个类是无用的类？</h4><blockquote>
<ol>
<li>类没有被加载：如果一个类还没有被加载到内存，那么他肯定是无用的类。</li>
<li>类的所有实例都已被回收：如果一个类的所有实例都已经被垃圾回收器回收，那么该类也可以认为是无用的类、</li>
<li>类的Class对象没有被引用：在Java中，每个类都有一个对应的Class对象，如果一个类的Class对象没有被其他对象引用，那么该类也可以被认为是无用的类。</li>
<li>类的实例被引用，但是该类没有任何方法被调用：如果一个类的实例被引用，但是该类没有任何方法被调用，那么该类也可以认为是无用的类。</li>
</ol>
<p>在实际应用中，我们可以使用一些工具来分析应用程序中的类的引用关系，从而找出无用的类。例如，可以使用JDK自带的工具jmap、jhat、jstat等，或者使用第三方工具如VisualVM等进行分析。</p>
</blockquote>
<h4 id="9、垃圾收集有哪些算法，各自的特点？"><a href="#9、垃圾收集有哪些算法，各自的特点？" class="headerlink" title="9、垃圾收集有哪些算法，各自的特点？"></a>9、垃圾收集有哪些算法，各自的特点？</h4><blockquote>
<ol>
<li>标记-清除算法（Mark-Sweep）：标记-清除算法是最早的垃圾回收算法之一，它分为标记和清除两个阶段。标记阶段会遍历所有的对象，并将被引用的对象标记为“存活”，未被标记的对象就是“垃圾”。清除阶段会将所有未被标记的对象回收。该算法的优点是简单易实现，但缺点是容易产生内存碎片。</li>
<li>复制算法（Copying）：复制算法将可用内存分为两个相等的区域，每次只使用其中一个区域，当这个区域用完之后，将还存活的对象复制到另一个区域中，然后将原来的区域全部清空。该算法的优点是不会产生内存碎片，但缺点是只能利用一半的内存空间。</li>
<li>标记-整理算法（Mark-Compact）：标记-整理算法也是一种标记式的垃圾回收算法，它在标记阶段与标记-清除算法类似，但在清除阶段不是直接回收未标记的对象，而是将所有存活的对象向一端移动，然后将另一端的空间全部回收。该算法的优点是不会产生内存碎片，但缺点是效率较低。</li>
<li>分代收集算法（Generational）：分代收集算法是现代垃圾回收算法中最常用的算法之一，它根据对象的存活周期将内存分为不同的代，通常将新生代分为Eden空间和两个Survivor空间，老年代则单独一块。一般情况下，新生代中的对象的存活时间较短，老年代中的对象的存活时间较长。分代收集算法可以针对不同代采用不同的垃圾回收算法，以提高回收效率和降低停顿时间。</li>
</ol>
<p>不同的垃圾回收算法有着不同的特点和适用场景，应根据实际应用场景选择合适的垃圾回收算法。例如，对于大型的服务器应用程序，可以使用CMS收集器或G1收集器等具有低停顿时间的算法；对于小型的客户端应用程序，可以使用Serial或Parallel收集器等具有高吞吐量的算法。</p>
</blockquote>
<h4 id="10、HotSpot为什么要分新生代和老年代？"><a href="#10、HotSpot为什么要分新生代和老年代？" class="headerlink" title="10、HotSpot为什么要分新生代和老年代？"></a>10、HotSpot为什么要分新生代和老年代？</h4><blockquote>
<ol>
<li>对象的生命周期不同</li>
<li>不同的垃圾回收算法适用于不同的区域</li>
</ol>
</blockquote>
<h4 id="11、常见的垃圾回收器有哪些？"><a href="#11、常见的垃圾回收器有哪些？" class="headerlink" title="11、常见的垃圾回收器有哪些？"></a>11、常见的垃圾回收器有哪些？</h4><p><img src="https://jovinbin-images.oss-cn-hangzhou.aliyuncs.com/202302011419939.png" alt="垃圾回收器"></p>
<blockquote>
<ol>
<li>Serial收集器：Serial收集器是最早的Java垃圾回收器，它是单线程的，只能使用单个CPU进行垃圾回收。Serial收集器适用于小型应用程序或客户端应用程序，它的优点是简单、高效、内存占用小，但缺点是垃圾回收过程可能会导致应用程序暂停。</li>
<li>Parallel收集器：Parallel收集器是Serial收集器的并行版本，它使用多线程进行垃圾回收，可以充分利用多核CPU的优势，提高垃圾回收效率。Parallel收集器适用于对吞吐量要求高的应用程序，如数据处理等，但它同样也可能导致应用程序暂停。</li>
<li>CMS收集器：CMS（Concurrent Mark Sweep）收集器是一种以低停顿时间为目标的垃圾回收器，它使用多线程并发收集，可以在应用程序运行时进行垃圾回收。CMS收集器适用于对应用程序停顿时间要求高的场景，如Web应用程序等。但是CMS收集器也有一些缺点，如容易产生碎片、垃圾回收效率相对较低等。三色标记算法</li>
<li>G1收集器：G1（Garbage First）收集器是一种面向服务端的垃圾回收器，它将堆内存分割成多个小块，每次只回收其中的一部分，可以有效避免全局垃圾回收导致的长时间停顿。G1收集器适用于对停顿时间和吞吐量都有要求的场景，如互联网服务、金融交易系统等。</li>
</ol>
</blockquote>
<h4 id="12、类加载过程"><a href="#12、类加载过程" class="headerlink" title="12、类加载过程"></a>12、类加载过程</h4><blockquote>
<p>在Java中，类加载是指将Java类的字节码加载到Java虚拟机中，并转换为Java对象的过程。Java类加载过程一般可以分为以下三个阶段：</p>
<ol>
<li><p>加载阶段：在这个阶段，Java虚拟机通过类加载器将类的字节码从磁盘或网络中加载到内存中，并在内存中创建一个对应的Class对象。这个Class对象包含了该类的完整信息，如类的方法、属性和父类等信息。</p>
</li>
<li><p>链接阶段：在这个阶段，Java虚拟机对类进行链接。具体来说，链接阶段包括以下三个步骤：</p>
<p>1）验证：对字节码进行验证，以确保字节码符合Java虚拟机规范，不会危害虚拟机自身的安全。</p>
<p>2）准备：为类的静态变量分配内存并初始化为默认值，如int类型的变量初始化为0，String类型的变量初始化为null等。</p>
<p>3）解析：将符号引用转换为直接引用，即将类、方法、字段等符号引用解析为在内存中的直接引用。</p>
</li>
<li><p>初始化阶段：在这个阶段，Java虚拟机执行类的静态初始化代码块。静态初始化代码块可以包含静态变量的赋值、静态代码块的执行等操作。当一个类被初始化时，它的父类也会被初始化，如果父类还有父类，则依次递归执行。</p>
</li>
</ol>
<p>值得注意的是，类的加载、链接和初始化阶段并非完全独立，它们之间可能存在依赖关系。例如，在解析阶段需要访问类的父类或接口，因此在加载和链接阶段也需要加载和链接父类或接口。</p>
<p>综上所述，Java类加载过程包括加载、链接和初始化三个阶段，这三个阶段之间可能存在依赖关系，它们共同完成将Java类的字节码加载到Java虚拟机中的过程。</p>
</blockquote>
<h3 id="六、Spring"><a href="#六、Spring" class="headerlink" title="六、Spring"></a>六、Spring</h3><h4 id="1、什么是Spring框架？"><a href="#1、什么是Spring框架？" class="headerlink" title="1、什么是Spring框架？"></a>1、什么是Spring框架？</h4><blockquote>
<p>Spring框架是一个开源的Java应用框架，它提供了一个全面的编程和配置模型，用于构建企业级应用程序和服务。Spring框架的核心特性包括：</p>
<ol>
<li>依赖注入（Dependency Injection）：通过IOC容器管理组件之间的依赖关系，将应用程序的组件解耦并进行松散耦合设计。</li>
<li>控制反转（IOC）：通过IOC容器管理组件之间的依赖关系，将应用程序的组件解耦并进行松散耦合设计。</li>
<li>面向切面编程（Aspect-Oriented Programming）：提供AOP框架，通过切面（Aspect）和通知（Advice）将横切关注点（Cross-cutting Concerns）从核心业务逻辑中分离出来，提高代码的可重用性和可维护性。</li>
<li>数据访问（Data Access）：提供ORM框架，支持多种数据源和持久化技术，如JDBC、Hibernate、MyBatis等，简化数据访问层的开发。</li>
<li>Web应用（Web Application）：提供Web MVC框架，支持RESTful架构、模板引擎、表单处理、文件上传等，简化Web应用的开发。</li>
<li>消息传递（Messaging）：提供消息中间件（Message Middleware）的支持，如JMS、AMQP等，使得应用程序之间可以使用异步方式进行通信。</li>
<li>测试（Testing）：提供JUnit、Mockito等测试框架的支持，使得应用程序的单元测试、集成测试等变得更加简单和高效。</li>
</ol>
<p>Spring框架的目标是提高Java应用程序的开发效率和质量，同时降低应用程序的复杂性和维护成本。它在业界得到了广泛的应用和认可，成为了Java应用开发的事实标准之一。</p>
</blockquote>
<h4 id="2、列举一些重要的Spring模块？"><a href="#2、列举一些重要的Spring模块？" class="headerlink" title="2、列举一些重要的Spring模块？"></a>2、列举一些重要的Spring模块？</h4><blockquote>
<p>Spring是一个非常庞大的框架，包含了很多不同的模块和组件，下面列举一些比较重要的Spring模块：</p>
<ol>
<li>Spring Core：Spring核心模块，提供了IoC容器的基本实现和管理机制，包括BeanFactory和ApplicationContext两个核心接口。</li>
<li>Spring AOP：基于面向切面编程（AOP）的模块，提供了AOP框架，支持切面、通知、切点等概念，可以实现事务管理、日志记录、安全控制等功能。</li>
<li>Spring ORM：提供了对对象关系映射（ORM）框架的支持，包括Hibernate、JPA等。</li>
<li>Spring JDBC：提供了对JDBC的支持，包括简化JDBC操作、异常处理、事务管理等功能。</li>
<li>Spring Web：提供了基于Servlet的Web开发框架，包括MVC框架、Websockets、REST支持等。</li>
<li>Spring Integration：提供了企业应用集成（EAI）的支持，包括消息传递、文件传输、远程调用等功能。</li>
<li>Spring Batch：提供了批处理的支持，包括任务调度、处理流程、监控等功能。</li>
<li>Spring Security：提供了安全框架的支持，包括身份认证、授权、访问控制等功能。</li>
</ol>
<p>除了以上列举的模块外，Spring还包括了很多其他的模块，如Spring Mobile、Spring HATEOAS、Spring Data等。这些模块都为Spring框架提供了丰富的功能和特性，使得Spring框架在不同的应用场景中都具有很高的适用性和灵活性。</p>
</blockquote>
<h4 id="3、-RestController和-Controller的区别？"><a href="#3、-RestController和-Controller的区别？" class="headerlink" title="3、@RestController和@Controller的区别？"></a>3、@RestController和@Controller的区别？</h4><blockquote>
<p><code>@RestController</code> 和 <code>@Controller</code> 是 Spring 框架中用来声明控制器的注解。它们的主要区别在于它们的作用和返回结果类型。</p>
<p>@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。</p>
<p><code>@Controller</code> 注解通常用于传统的 Web 应用程序中，它表示这是一个控制器类，它可以处理 HTTP 请求和响应。通常情况下，它处理完请求后需要返回一个视图，比如一个 HTML 页面或者一个 JSP 页面。因此，<code>@Controller</code> 注解的方法通常返回一个 <code>String</code> 类型，这个字符串是视图名称或者视图的完整路径。</p>
<p>相反，<code>@RestController</code> 注解通常用于编写 RESTful 风格的 Web 服务或者 API 接口，它表示这是一个控制器类，它可以处理 HTTP 请求和响应。但是，它的返回结果类型不是视图，而是数据。<code>@RestController</code> 注解的方法通常返回一个 Java 对象，这个对象会被自动序列化为 JSON 或者 XML 格式的数据，并返回给客户端。</p>
<p>因此，<code>@RestController</code> 注解通常比 <code>@Controller</code> 更为简单和方便，因为它可以直接返回数据而不需要进行视图解析。同时，使用 <code>@RestController</code> 可以更好地实现前后端分离，将前端和后端逻辑分开，提高了代码的可维护性和可读性。</p>
</blockquote>
<h4 id="4、讲一下Spring-IOC和AOP"><a href="#4、讲一下Spring-IOC和AOP" class="headerlink" title="4、讲一下Spring IOC和AOP"></a>4、讲一下Spring IOC和AOP</h4><blockquote>
<p>Spring是一个Java开发的框架，提供了很多特性，其中最核心的特性之一是IOC（Inversion of Control）和AOP（Aspect Oriented Programming）。</p>
<p>IOC（控制反转）是指将控制权从应用程序代码中解耦出来，让容器负责管理对象之间的依赖关系。在Spring中，通过容器管理Bean对象，可以在需要时将它们注入到其他对象中。这样，应用程序就可以专注于实现业务逻辑，而不必关心对象之间的依赖关系。Spring提供了多种方式实现IOC，包括XML配置、Java注解、Java配置等。</p>
<p>AOP（面向切面编程）是指将跨越多个方法或对象的功能（如日志记录、性能监控等）封装起来，从而简化代码，提高代码的重用性和可维护性。在Spring中，通过AOP可以在不修改原有代码的情况下，实现一些横切关注点（crosscutting concern），如事务管理、异常处理、缓存等。Spring的AOP实现基于代理模式，通过动态代理来实现。</p>
<p>Spring的IOC和AOP是Spring框架的两个核心特性，它们可以提高应用程序的模块化和可重用性，使代码更加易于维护和扩展。</p>
</blockquote>
<h4 id="5、Spring中的bean的作用域有哪些？"><a href="#5、Spring中的bean的作用域有哪些？" class="headerlink" title="5、Spring中的bean的作用域有哪些？"></a>5、Spring中的bean的作用域有哪些？</h4><blockquote>
<p>在Spring中，Bean的作用域是指Bean对象在Spring容器中的生命周期和可见范围。Spring支持以下5种Bean作用域：</p>
<ol>
<li>Singleton：单例模式，一个Spring容器中只有一个Bean实例，默认作用域。通过Spring容器获取同一个Bean对象，每次都是返回同一个实例对象。</li>
<li>Prototype：原型模式，每次从Spring容器中获取Bean对象时，都会创建一个新的实例对象。即每次获取Bean时，都会创建一个新的Bean实例。</li>
<li>Request：每个HTTP请求都会创建一个新的Bean实例，在请求处理完成后，Bean实例就会被销毁。仅在Web应用程序中使用。</li>
<li>Session：与Request作用域类似，但作用于整个会话期间。在用户会话结束时，Bean实例被销毁。仅在Web应用程序中使用。</li>
<li>GlobalSession：在Portlet环境下使用，每个用户会话中只有一个Bean实例，作用于整个应用程序。</li>
</ol>
<p>以上这些作用域是通过Spring的BeanFactory和ApplicationContext来实现的。可以在XML配置文件或Java代码中通过“scope”属性指定Bean的作用域，例如：</p>
</blockquote>
<h4 id="6、Spring中的单例bean的线程安全问题？"><a href="#6、Spring中的单例bean的线程安全问题？" class="headerlink" title="6、Spring中的单例bean的线程安全问题？"></a>6、Spring中的单例bean的线程安全问题？</h4><blockquote>
<p>在Spring中，单例（Singleton）作用域的Bean是默认的作用域，即在整个应用程序中只有一个实例。因此，在使用单例Bean时需要考虑线程安全的问题。</p>
<p>如果单例Bean是无状态的（即不存储任何状态信息），那么它是线程安全的，可以同时在多个线程中使用。但是，如果单例Bean是有状态的（即存储了状态信息），那么在多线程环境下可能会存在线程安全问题，需要采取一些措施保证线程安全。</p>
<p>下面介绍几种保证单例Bean线程安全的方法：</p>
<ol>
<li>避免共享状态：将单例Bean设计为无状态的，避免存储共享状态信息，这样就可以避免线程安全问题。</li>
<li>同步访问：使用synchronized关键字或者Lock对象等机制，在访问有状态的单例Bean时进行同步，保证同一时刻只有一个线程访问。</li>
<li>使用ThreadLocal：将有状态的单例Bean的状态信息存储在ThreadLocal对象中，这样每个线程都有自己独立的状态信息，从而避免线程安全问题。</li>
<li>使用代理对象：使用代理对象来访问有状态的单例Bean，代理对象控制对单例Bean的访问，从而保证线程安全。</li>
</ol>
<p>总之，Spring中的单例Bean可能存在线程安全问题，需要在实现时考虑线程安全问题，使用适当的线程安全技术来保证单例Bean的线程安全性。</p>
</blockquote>
<h4 id="7、-Component和-Bean的区别是什么？"><a href="#7、-Component和-Bean的区别是什么？" class="headerlink" title="7、@Component和@Bean的区别是什么？"></a>7、@Component和@Bean的区别是什么？</h4><blockquote>
<p>作用对象不同：</p>
<ol>
<li><strong>@Component</strong>注解作用于类</li>
<li><strong>@Bean</strong>作用于方法</li>
</ol>
<p>使用方法不同：</p>
<ol>
<li><strong>@Component</strong>注解直接标注在类声明上即可</li>
<li><strong>@Bean</strong>需要在配置类中使用，即类上需要加上@Configuration注解，然后在配置类中使用一个方法定义bean是如何创建的</li>
</ol>
<p>实现不同：</p>
<ol>
<li><strong>@Component注解通常是通过类路径扫描来自动侦测以及自动装配到spring容器中（使用</strong>Component注解定义要扫描的路径<strong>）</strong></li>
<li><strong>@Bean注解通常是在标有</strong>@Configuration注解的方法中定义产生的这个bean，默认情况下，它将使用方法的名称作为bean的id</li>
</ol>
<p>灵活性不同：</p>
<ol>
<li>@Bean注解比@Component注解灵活，我们可以按需注册需要的bean，很多场景我们只能通过@Bean来注册bean，比如引入第三方库中农的类需要装配到spring容器中。</li>
</ol>
</blockquote>
<h4 id="8、将一个类声明为Spring的bean的注解有哪些？"><a href="#8、将一个类声明为Spring的bean的注解有哪些？" class="headerlink" title="8、将一个类声明为Spring的bean的注解有哪些？"></a>8、将一个类声明为Spring的bean的注解有哪些？</h4><blockquote>
<p>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired注解自动装配的 bean 的类,采用以下注解可实现：</p>
<p>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用</p>
<p>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</p>
<p>@Service :对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</p>
<p>@Controller : 对应 Spring MVC控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p>
</blockquote>
<h4 id="9、Spring中bean的生命周期？"><a href="#9、Spring中bean的生命周期？" class="headerlink" title="9、Spring中bean的生命周期？"></a>9、Spring中bean的生命周期？</h4><blockquote>
<p>大致分为以下几个阶段：</p>
<ol>
<li>实例化 Bean</li>
<li>设置 Bean 属性</li>
<li>调用 Bean 的初始化方法</li>
<li>Bean 可以使用</li>
<li>当容器关闭时，调用 Bean 的销毁方法</li>
</ol>
</blockquote>
<h4 id="10、Spring-MVC工作原理？"><a href="#10、Spring-MVC工作原理？" class="headerlink" title="10、Spring MVC工作原理？"></a>10、Spring MVC工作原理？</h4><blockquote>
<p>Spring MVC是Spring框架中的一个模块，它是基于MVC（Model-View-Controller）设计模式的Web框架，用于处理Web应用程序的请求和响应。</p>
<p>Spring MVC框架的工作流程如下：</p>
<ol>
<li>首先，客户端发送请求到DispatcherServlet。</li>
<li>DispatcherServlet是Spring MVC框架的核心控制器，他接收所有的客户端请求，并负责将请求发送给对应的处理器。</li>
<li>HandlerMapping是Spring MVC框架的一个组件，它负责将请求映射到对应的处理器（即Controller）。</li>
<li>一旦找到了合适的Controller，DispatcherServlet就会将请求发送给它。</li>
<li>Controller接受请求，并调用相应的业务逻辑进行处理，并返回一个Model And View对象。</li>
<li>Model And View是一个包含了视图名称和模型数据的对象。视图名称用于标识视图（即JSP页面），而模型数据则是Controller处理请求后产生的数据。</li>
<li>ViewResolver是Spring MVC框架的另一个组件，他将视图名称解析成一个具体的视图（即JSP页面）。</li>
<li>一旦找到了合适的试图，DispatcherServlet就会将模型数据传递给视图进行渲染。</li>
<li>最后，DispatcherServlet将渲染后的视图返回给客户端，完成整个请求处理过程。</li>
</ol>
<p>总之，Spring MVC框架通过DispatcherServlet、HandlerMapping、Controller、ModelAndView、ViewResolver等组件协同工作，将客户端请求转化为相应的响应结果，并将结果返回给客户端。</p>
</blockquote>
<h4 id="11、Spring框架中用到了哪些设计模式？"><a href="#11、Spring框架中用到了哪些设计模式？" class="headerlink" title="11、Spring框架中用到了哪些设计模式？"></a>11、Spring框架中用到了哪些设计模式？</h4><blockquote>
<p>Spring框架是一个庞大的框架，其中涉及到了多种设计模式。以下是一些常见的设计模式在Spring框架中的应用：</p>
<ol>
<li>依赖注入（DI）&#x2F; 控制反转（IOC）：这是Spring框架最基本的设计模式，用于将对象之间的依赖关系从编码时确定转换成配置时确定，从而减少代码之间的耦合。Spring框架通过依赖注入将对象之间的依赖关系转交给框架进行管理。</li>
<li>AOP（面向切面编程）：AOP是一种通过在程序执行期间动态地将代码切入到类的指定方法或特定点上的编程方式，它可以帮助程序员将应用程序中的各个方面解耦并提供横切关注点的重用性。在Spring框架中，AOP可以用于事务管理、安全检查等方面。</li>
<li>模板方法模式：Spring框架提供了一些模板类，比如JdbcTemplate和HibernateTemplate等，这些模板类将一些通用的操作封装在模板方法中，以减少代码的冗余度和提高代码的可读性。</li>
<li>工厂模式：Spring框架提供了很多工厂类来创建对象，比如BeanFactory和ApplicationContext等，这些工厂类负责创建和管理对象，以解耦应用程序的配置和实现。</li>
<li>单例模式：Spring框架中的bean默认都是单例的，也就是说，在应用程序的整个生命周期中，每个bean只有一个实例，这符合单例模式的设计思想。</li>
<li>观察者模式：Spring框架中的事件机制就是一个典型的观察者模式的应用，当某个事件发生时，观察者对象将会收到通知并作出相应的反应。</li>
</ol>
</blockquote>
<h4 id="12、Spring事务中的隔离级别有哪几种？"><a href="#12、Spring事务中的隔离级别有哪几种？" class="headerlink" title="12、Spring事务中的隔离级别有哪几种？"></a>12、Spring事务中的隔离级别有哪几种？</h4><blockquote>
<p>Sping 中的事务隔离级别有 5 种，它们分别是：</p>
<ol>
<li>DEFAULT： Spring 中默认的事务隔离级别 ，以连接的数据库的事务隔离级别为准；</li>
<li>READ_UNCOMMITTED：读未提交，也叫未提交读，该隔离级别的事务可以看到其他事务中未提交的数据。该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读；</li>
<li>READ_COMMITTED：读已提交，也叫提交读，该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读；</li>
<li>REPEATABLE_READ：可重复读，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）；</li>
<li>SERIALIZABLE：串行化，最高的事务隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。</li>
</ol>
<p>所以， 相比于 MySQL 的事务隔离级别，Spring 中多了一种 DEFAULT 的事务隔离级别 。</p>
</blockquote>
<h4 id="13、Spring事务中有哪几种事务的传播行为？"><a href="#13、Spring事务中有哪几种事务的传播行为？" class="headerlink" title="13、Spring事务中有哪几种事务的传播行为？"></a>13、Spring事务中有哪几种事务的传播行为？</h4><blockquote>
<ol>
<li>REQUIRED：如果当前没有事务，则新建一个事务；如果已经存在事务，则加入该事务。适用于大多数业务场景，保证了业务操作的完整性和一致性。</li>
<li>SUPPORTS：如果当前存在事务，则加入该事务；如果不存在事务，则以非事务方式执行。适用于读取操作，避免不必要的事务开销。</li>
<li>MANDATORY：必须在已存在的事务中执行，否则抛出异常。适用于要求业务操作必须在事务中进行的场景。</li>
<li>REQUIRES_NEW：每次都会新建一个事务，如果当前存在事务，则将当前事务挂起，并新建一个事务进行操作。适用于某些业务操作需要独立的事务环境，不受外部事务的影响。</li>
<li>NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则将其挂起。适用于一些无需事务支持的操作，如清空日志、统计数据等。</li>
<li>NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。适用于一些绝对不需要事务支持的操作。</li>
<li>NESTED：如果存在事务，则在该事务中创建一个新的嵌套事务，如果不存在事务，则新建一个事务。内部事务可以独立提交或回滚，不影响外部事务的提交或回滚。适用于某些需要进行子业务操作的场景。</li>
</ol>
<p>下面是每个传播行为的具体案例：</p>
<ol>
<li>REQUIRED：一个银行转账操作，转账过程需要对转出账户和转入账户进行更新，这两个操作需要在同一个事务中执行。</li>
<li>SUPPORTS：查询用户信息，不需要对数据库进行更新操作，因此不需要使用事务。</li>
<li>MANDATORY：对于更新用户信息这种必须使用事务的操作，如果在没有事务的情况下执行，就需要抛出异常。</li>
<li>REQUIRES_NEW：某个业务需要对一批数据进行删除和新增操作，但是删除操作需要在事务中进行，新增操作不需要，可以使用REQUIRES_NEW来新建一个事务进行删除操作。</li>
<li>NOT_SUPPORTED：清空日志的操作可以使用NOT_SUPPORTED，因为它不需要事务的支持。</li>
<li>NEVER：删除某个数据，如果在事务中执行，可能会引起其他数据的不一致，因此可以使用NEVER来禁止事务。</li>
<li>NESTED：某个订单涉及多个子订单，如果某个子订单操作失败，可以回滚该子订单的操作，而不会影响其他子订单或者主订单的状态，这时可以使用NESTED。</li>
</ol>
</blockquote>
<h4 id="14、-Transactionl-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#14、-Transactionl-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="14、@Transactionl(rollbackFor &#x3D; Exception.class)注解了解吗？"></a>14、@Transactionl(rollbackFor &#x3D; Exception.class)注解了解吗？</h4><blockquote>
<p>在项目中，@Transactional(rollbackFor&#x3D;Exception.class)，如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor&#x3D;Exception.class,可以让事物在遇到非运行时异常时也回滚</p>
</blockquote>
<h3 id="七、Redis"><a href="#七、Redis" class="headerlink" title="七、Redis"></a>七、Redis</h3><h4 id="1、Redis为什么这么快？"><a href="#1、Redis为什么这么快？" class="headerlink" title="1、Redis为什么这么快？"></a>1、Redis为什么这么快？</h4><blockquote>
<p>Redis内部做了非常多的性能优化，比较重要的主要有以下三点：</p>
<ul>
<li>Redis基于内存，内存的访问速度是磁盘的上千倍；</li>
<li>Redis基于Reactor模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和IO多路复用；</li>
<li>Redis内置了多种优化过后的数据结构实现，性能非常高。</li>
</ul>
</blockquote>
<h4 id="2、说一下Redis和Memcached的区别和共同点"><a href="#2、说一下Redis和Memcached的区别和共同点" class="headerlink" title="2、说一下Redis和Memcached的区别和共同点"></a>2、说一下Redis和Memcached的区别和共同点</h4><blockquote>
<p>现在一般都是用Redis来实现缓存。</p>
<p>共同点：</p>
<ul>
<li>都是基于内存的数据库，一般都用来当缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ul>
<p>区别：</p>
<ul>
<li><p><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</p>
<p><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></p>
<p><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</p>
<p><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></p>
<p><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></p>
<p><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</p>
<p><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></p>
<p><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></p>
</li>
</ul>
</blockquote>
<h4 id="3、为什么要用Redis-x2F-为什么要用缓存？"><a href="#3、为什么要用Redis-x2F-为什么要用缓存？" class="headerlink" title="3、为什么要用Redis&#x2F;为什么要用缓存？"></a>3、为什么要用Redis&#x2F;为什么要用缓存？</h4><blockquote>
<p>主要从“高性能”和“高并发”这两个点来进行讲解。</p>
<p><strong>高性能</strong>：</p>
<ul>
<li>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢的，因为是从硬盘中读取的。但是，如果用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</li>
</ul>
<p><strong>高并发</strong>：</p>
<ul>
<li><p>一般像MySQL这类的数据库的QPS大概都在1w左右（4核8g），但是使用Redis缓存之后很容易达到10w+，甚至最高能达到30w+（就单机Redis的情况，Redis集群的话会更高）。</p>
<p><code>QPS（Query Per Second）</code>：服务器每秒可以执行的查询次数。</p>
</li>
</ul>
</blockquote>
<h4 id="4、Redis处理做缓存，还能做什么？"><a href="#4、Redis处理做缓存，还能做什么？" class="headerlink" title="4、Redis处理做缓存，还能做什么？"></a>4、Redis处理做缓存，还能做什么？</h4><blockquote>
<ul>
<li>分布式锁：通过Redis来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于Redisson来实现分布式锁。</li>
<li>限流：一般是通过Redis + Lua脚本的方式来实现限流的。</li>
<li>消息队列：Redis自带的list数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li>复杂业务场景：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
</ul>
</blockquote>
<h4 id="5、Redis常用的数据结构有哪些？"><a href="#5、Redis常用的数据结构有哪些？" class="headerlink" title="5、Redis常用的数据结构有哪些？"></a>5、Redis常用的数据结构有哪些？</h4><blockquote>
<ul>
<li>5种基础数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li>3种特殊的数据结构：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
</blockquote>
<h4 id="6、Redis内存淘汰机制"><a href="#6、Redis内存淘汰机制" class="headerlink" title="6、Redis内存淘汰机制"></a>6、Redis内存淘汰机制</h4><blockquote>
<p>首先先来讲一讲过期数据的删除策略吧。</p>
<ul>
<li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ul>
<p>定期删除对内存更加友好，惰性删除对CPU更加友好。而Redis是采用的<code>定期删除 + 惰性/懒汉式删除</code>。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>解决这个问题就要讲到<strong>Redis内存淘汰机制</strong>了。</p>
<p><code>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</code></p>
<p>Redis提供了6种数据淘汰策略：</p>
<ul>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ul>
</blockquote>
<h4 id="7、什么是RDB持久化"><a href="#7、什么是RDB持久化" class="headerlink" title="7、什么是RDB持久化"></a>7、什么是RDB持久化</h4><blockquote>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save <span class="token number">900</span> <span class="token number">1</span>           <span class="token comment">#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span>

save <span class="token number">300</span> <span class="token number">10</span>          <span class="token comment">#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span>

save <span class="token number">60</span> <span class="token number">10000</span>        <span class="token comment">#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>save</code> : 主线程执行，会阻塞主线程；</li>
<li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li>
</ul>
</blockquote>
<h4 id="8、什么是AOF持久化？"><a href="#8、什么是AOF持久化？" class="headerlink" title="8、什么是AOF持久化？"></a>8、什么是AOF持久化？</h4><blockquote>
<p>AOP持久化：将Redis执行的每条命令记录在一个日志文件中，以便在Redis重启时重新执行这些命令。可以选择每秒钟同步日志文件到磁盘中，或者在Redis退出时同步。该方式的缺点是会导致较慢的性能。</p>
</blockquote>
<h4 id="9、Redis的集群模式有哪些？"><a href="#9、Redis的集群模式有哪些？" class="headerlink" title="9、Redis的集群模式有哪些？"></a>9、Redis的集群模式有哪些？</h4><blockquote>
<ul>
<li>主从复制模式：一个主节点可以拥有多个从节点 ，主节点将数据同步到从节点上。从节点可以处理读请求，主节点可以处理写请求。</li>
<li>Sentinel模式：是Redis的一个分布式系统，用于监控Redis主节点的状态。当主节点宕机时，Sentinel会选举一个新的主节点，并通知所有的客户端切换到新的主节点上。</li>
<li>Redis Cluster模式：时Redis的分布式集群模式。它将数据分片存储在多个节点上，并使用复制机制提高可用性和容错性。</li>
</ul>
</blockquote>
<h4 id="10、Redis如何保证数据的一致性？"><a href="#10、Redis如何保证数据的一致性？" class="headerlink" title="10、Redis如何保证数据的一致性？"></a>10、Redis如何保证数据的一致性？</h4><blockquote>
<p>Redis采用单线程模式处理命令需求，因此不存在多线程并发问题。Redis通过使用原子操作和基于事务的命令来解决并发问题。Redis还提供了乐观锁和悲观锁等机制，可以根据实际情况选择合适的锁机制。</p>
</blockquote>
<h4 id="11、Redis的性能瓶颈是什么？"><a href="#11、Redis的性能瓶颈是什么？" class="headerlink" title="11、Redis的性能瓶颈是什么？"></a>11、Redis的性能瓶颈是什么？</h4><blockquote>
<ul>
<li>网络带宽限制：在高并发情况下，网络带宽可能成为Redis的性能瓶颈。</li>
<li>CPU和内存资源限制：当Redis存储的数据量非常大时，CPU和内存可能成为性能瓶颈。</li>
<li>持久化性能限制：持久化操作可能会影响Redis的性能。</li>
<li>键值的存储和查询效率：在某些情况下，Redis的键值存储和查询效率可能会成为性能瓶颈。</li>
</ul>
</blockquote>
<h4 id="12、Redis如何保证高可用性？"><a href="#12、Redis如何保证高可用性？" class="headerlink" title="12、Redis如何保证高可用性？"></a>12、Redis如何保证高可用性？</h4><blockquote>
<p>Redis通过主从复制和Sentinel模式提供高可用性支持。在主从复制中，Redis可以将数据同步到多个从节点上，当主节点宕机时，从节点可以接管主节点的工作，从而保证Redis的可用性。在Sentinel模式中，Sentinel可以监控Redis主节点的状态，当主节点宕机时，Sentinel会选举一个新的主节点，并通知所有客户端切换到新的主节点上。</p>
</blockquote>
<h4 id="13、Redis的缓存穿透、缓存击穿和缓存雪崩问题如何解决？"><a href="#13、Redis的缓存穿透、缓存击穿和缓存雪崩问题如何解决？" class="headerlink" title="13、Redis的缓存穿透、缓存击穿和缓存雪崩问题如何解决？"></a>13、Redis的缓存穿透、缓存击穿和缓存雪崩问题如何解决？</h4><blockquote>
<ul>
<li><p>缓存穿透</p>
<p>缓存穿透是指请求一个不存在的数据，由于缓存中没有这个数据，每次请求都会穿透到数据库中，造成数据库的压力 。</p>
<ul>
<li>可以使用布隆过滤器，对请求的key进行预处理过滤掉不存在的key。</li>
<li>在缓存中假如空对象或默认值，使缓存中始终存在该数据的建，减少缓存穿透的概率。</li>
</ul>
</li>
<li><p>缓存击穿</p>
<p>缓存击穿是指某个热点数据在缓存中过期或被删除后，大量请求同时访问该数据，导致请求直接穿透到数据库，压垮数据库，引起系统崩溃。</p>
<ul>
<li>设置热点数据的过期时间，采用随机时间的方式，避免缓存同时失效。</li>
<li>采用分布式锁，只允许一个线程访问数据库，其他线程等待该线程从数据库中加载数据到缓存中后再访问。</li>
<li>对热点数据不设置过期时间，或者使用永久缓存等方式，保证数据一直存在于缓存中，避免缓存失效。</li>
</ul>
</li>
<li><p>缓存雪崩</p>
<p>缓存雪崩是指缓存中大量的数据在同一时间过期或失效，导致大量请求直接访问数据库，引起数据库的宕机或系统崩溃。</p>
<ul>
<li>设置缓存失效时间，采用分布式随机时间的方式，避免大量的缓存同时失效。</li>
<li>采用多级缓存架构，例如增加本地缓存或CDN缓存，减轻单一缓存的压力。</li>
<li>在缓存中增加限流、熔断等机制，限制请求的访问量，避免突发的请求了过大。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="14、Redis如何处理高并发请求？"><a href="#14、Redis如何处理高并发请求？" class="headerlink" title="14、Redis如何处理高并发请求？"></a>14、Redis如何处理高并发请求？</h4><blockquote>
<ul>
<li>增加Redis实例：通过增加Redis集群，可以实现更加高效的缓存读写，</li>
<li>并提高系统的并发处理能力。</li>
<li>使用Redis集群：通过Redis集群，可以将缓存数据分散到不同的Redis节点上，从而实现更好的并发处理能力。</li>
<li>使用Redis缓存预热：在系统启动时，将热点数据提前加载到Redis缓存中，可以避免大量请求同时访问缓存造成的性能问题。</li>
<li>使用Redis Pipeline：Redis Pipeline可以在一次网络通信中同时执行多个命令，从而提高缓存读写的效率和响应速度。</li>
<li>使用Redis分布式锁：当多个请求同时访问同一资源时，可以使用Redis分布式锁实现对资源的加锁，从而避免并发冲突问题。</li>
</ul>
</blockquote>
<h4 id="15、Redis中的事务是什么？"><a href="#15、Redis中的事务是什么？" class="headerlink" title="15、Redis中的事务是什么？"></a>15、Redis中的事务是什么？</h4><blockquote>
<p>Redis中的事务是一组命令的集合，可以作为一个单独的操作执行。在Redis事务中，可以将多个命令组合成一个原子操作，从而实现更加复杂的操作。</p>
<p>Redis中的事务具有以下特点：</p>
<ul>
<li>原子性：Redis中的事务是一个原子操作，要么全部执行成功，要么全部执行失败，不会出现部分执行的情况。</li>
<li>隔离性：Redis中的事务是隔离的，事务中的命令不会被其他客户端请求所干扰。</li>
<li>可重入性：Redis中的事务是可重入的，可以在一个事务中嵌套另一个事务。</li>
<li>回滚操作：当事务执行失败时，Redis会自动回滚事务，撤销已执行的命令。</li>
</ul>
</blockquote>
<h3 id="八、Kafka"><a href="#八、Kafka" class="headerlink" title="八、Kafka"></a>八、Kafka</h3><h4 id="1、Kafka的基本概念是什么？"><a href="#1、Kafka的基本概念是什么？" class="headerlink" title="1、Kafka的基本概念是什么？"></a>1、Kafka的基本概念是什么？</h4><blockquote>
<p>Kafka是一个分布式的消息队列系统，基于发布-订阅模型。它包含了生产者、消费者和Broker三个核心组件。生产者可以将消息发送到Kafka集群，消费者可以从Kafka集群中订阅并消费消息，Broker则是在Kafka集群中的存储和转发节点。</p>
</blockquote>
<h4 id="2、Kafka的数据存储模型是什么？"><a href="#2、Kafka的数据存储模型是什么？" class="headerlink" title="2、Kafka的数据存储模型是什么？"></a>2、Kafka的数据存储模型是什么？</h4><blockquote>
<p>Kafka的数据存储模型是基于日志的。所有的消息都被追加到一个或多个分区中，每个分区都由多个消息组成，每条消息都有一个连续的偏移量。Kafka使用分布式提交日志（Distributed Commit Log）来保存消息，这种方式可以保证高可用性和持久性。</p>
</blockquote>
<h4 id="3、Kafka的主要优点是什么？"><a href="#3、Kafka的主要优点是什么？" class="headerlink" title="3、Kafka的主要优点是什么？"></a>3、Kafka的主要优点是什么？</h4><blockquote>
<ul>
<li>高吞吐量：Kafka能够处理大量的数据，支持每秒处理几百万条消息。</li>
<li>可靠性：Kafka使用分布式提交日志来保证消息的持久性和可靠性。</li>
<li>可扩展性：Kafka的数据分片存储模型支持水平扩展，可以随着数据量的增长而扩展。</li>
<li>实时性：Kafka的消息能够实时地被消费者订阅和处理。</li>
<li>灵活性：Kafka支持多种编程语言和平台，可以与各种数据处理系统集成。</li>
</ul>
</blockquote>
<h4 id="4、Kafka的消费者处理如何保障消息的顺序？"><a href="#4、Kafka的消费者处理如何保障消息的顺序？" class="headerlink" title="4、Kafka的消费者处理如何保障消息的顺序？"></a>4、Kafka的消费者处理如何保障消息的顺序？</h4><blockquote>
<p>在Kafka中，每个主题（Topic）可以被分为多个分区（Partition），每个分区内的消息是有序的，但不同分区的消息是无序的。当一个消费者从一个分区中拉取消息时，Kafka保证消息的顺序不变。但是，当多个消费者同时从多个分区中拉取消息时，Kafka不能保证消息的全局顺序，因为不同的分区的消息是无序的。</p>
<p>如果应用需要保证消息的全局顺序，可以将消息发送到一个分区中，这样消费者在处理消息时就能保证消息的全局顺序。另外，Kafka还支持消息的批量发送和消费，可以提高消息的吞吐量和效率。</p>
</blockquote>
<h4 id="5、Kafka的数据如何保证不被重复消费？"><a href="#5、Kafka的数据如何保证不被重复消费？" class="headerlink" title="5、Kafka的数据如何保证不被重复消费？"></a>5、Kafka的数据如何保证不被重复消费？</h4><blockquote>
<p>生产者角度：</p>
<ul>
<li>设置正确的分区（partition）数量和副本（replication factor）数量：在生产者将消息发送到主题之前，需要考虑主题的分区和副本数量，以确保消息能够在不同的消费者之前均衡地分配和复制。</li>
<li>采用幂等性：幂等性生产者可以保证即使在网络延迟或重试情况下，也不会发送重复的消息。可以通过设置<code>enable.idempotence=true</code>参数启用。</li>
</ul>
<p>消费者角度：</p>
<ul>
<li><p>使用消费者组(Consumer Group)：消费者组可以确保同一组中的消费者不会重复消费同一条消息，每个消息只会被组内的一个消费者处理。因此，在使用Kafka时，应该为每个消费者组分配一个唯一的组ID。</p>
</li>
<li><p>启用自动提交(offset commit)：Kafka提供了两种提交偏移量(offset)的方式：手动提交和自动提交。启用自动提交可以确保在消费者异常退出或崩溃时，偏移量能够被定期提交到Kafka服务器上。</p>
</li>
<li><p>限制消费者的并行度(parallelism)：限制消费者的并行度可以确保同一消费者组中的消费者数量不会过多，减少重复消费的可能性。</p>
</li>
</ul>
</blockquote>
<h4 id="6、Kafka的消息可靠性如何保证（如何避免消息丢失）？"><a href="#6、Kafka的消息可靠性如何保证（如何避免消息丢失）？" class="headerlink" title="6、Kafka的消息可靠性如何保证（如何避免消息丢失）？"></a>6、Kafka的消息可靠性如何保证（如何避免消息丢失）？</h4><blockquote>
<p>生产者</p>
<ul>
<li>提高消息的可靠性：通过设置参数来保证消息的可靠性，例如将 <code>acks</code> 参数设置为 <code>all</code>，即需要所有的副本都收到消息才认为消息发送成功，这样可以减少消息丢失的可能性。</li>
<li>使用消息确认机制：在发送消息后，等待 Kafka 返回确认信息，如果确认信息未收到，可以重新发送消息，保证消息不会丢失。</li>
<li>使用事务机制：通过事务机制可以将多个操作视为一个原子操作，如果其中任何一个操作失败，整个事务将被回滚，这样可以保证消息不会丢失。</li>
</ul>
<p>消费者</p>
<ul>
<li>提高消息消费的可靠性：通过手动提交偏移量，可以避免由于自动提交偏移量而导致的消息丢失。</li>
<li>增加消息的重试机制：在处理消息时，如果发现消息处理失败，可以将消息重新放回队列中，等待重新处理，这样可以保证消息不会丢失。</li>
<li>增加消息的容错机制：在处理消息时，如果发现某个消费者实例异常退出，可以通过增加副本或重新分配消费者实例等方式来保证消息不会丢失。</li>
</ul>
</blockquote>
<h4 id="7、Kafka的副本机制是？"><a href="#7、Kafka的副本机制是？" class="headerlink" title="7、Kafka的副本机制是？"></a>7、Kafka的副本机制是？</h4><blockquote>
<p>Kafka的副本机制时保证消息高可用性和可靠性的重要手段。Kafka中的每个分区都可以配置多个副本，其中一个副本被称为领导者（Leader），其他副本被称为追随者（Follower）。</p>
<p>Leader负责处理消息的读写请求，并将数据同步到Follower副本。Follower副本只负责从Leader副本中拉取消息，不参与消息的写入。当Leader副本宕机时，其中一个Follower副本会被选举为新的Leader，继续处理消息的读写请求。</p>
<p>Kafka的副本机制可以提高系统的可用性和容错性，因为当某个副本宕机时，其他副本可以继续处理消息，保证数据不丢失。此外，Kafka还支持多数据中心复制（Multi-Datacenter Replication），可以将消息复制到不同的数据中心，提高数据的可用性和灾备能力。</p>
</blockquote>
<h4 id="8、Kafka为什么能够处理大批量的数据（削峰）"><a href="#8、Kafka为什么能够处理大批量的数据（削峰）" class="headerlink" title="8、Kafka为什么能够处理大批量的数据（削峰）"></a>8、Kafka为什么能够处理大批量的数据（削峰）</h4><blockquote>
<p>Kafka之所以能够处理大批量的数据，其中一个重要的原因是其具有削峰能力。削峰指的是能够平滑处理突发的数据流量，而不会因为流量突增导致系统崩溃或性能下降的情况。下面是几个可以解释Kafka削峰能力的原因：</p>
<ul>
<li>消费者消费数据速度的控制：Kafka消费者可以自行控制消费数据的速度，即可以通过调整消费者的线程数或使用批量消费的方式来控制每个消费者消费的速度。这样可以避免过多的消息堆积在Kafka中，从而平滑处理突发的数据流量。</li>
<li>消息缓存的机制：Kafka具有消息缓存的机制，即将消息存储在内存中，以提高读写性能。消息缓存可以缓解瞬时数据量的压力，让Kafka能够处理更高的并发请求。</li>
<li>分区机制的使用：Kafka使用分区机制将主题分为多个分区，每个分区都可以被多个消费者消费。通过分区机制，可以将数据均匀地分布在多个分区中，从而提高了Kafka的并发处理能力。</li>
<li>异步的数据写入：Kafka生产者使用异步的方式将消息写入Kafka集群中。生产者会将消息存储在本地缓存中，而不是直接发送到Kafka集群，然后再批量地将缓存中的消息发送到Kafka。这样可以避免瞬时大量的请求导致集群性能下降。</li>
<li>副本机制的使用：Kafka通过复制分区副本的方式来保证数据的可靠性。副本机制可以缓解由于单一节点故障或网络异常等原因导致的数据丢失问题，从而保证了数据的可靠性和Kafka集群的稳定性。同时，多个副本也可以同时处理请求，提高Kafka的并发处理能力。</li>
</ul>
</blockquote>
<h3 id="🌙、网络"><a href="#🌙、网络" class="headerlink" title="🌙、网络"></a>🌙、网络</h3><h4 id="1、OSI与TCP-x2F-IP各层的结构与功能，都有哪些协议？"><a href="#1、OSI与TCP-x2F-IP各层的结构与功能，都有哪些协议？" class="headerlink" title="1、OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议？"></a>1、OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议？</h4><h4 id="2、TCP三次握手与四次挥手"><a href="#2、TCP三次握手与四次挥手" class="headerlink" title="2、TCP三次握手与四次挥手?"></a>2、TCP三次握手与四次挥手?</h4><h4 id="3、TCP、UDP协议的区别"><a href="#3、TCP、UDP协议的区别" class="headerlink" title="3、TCP、UDP协议的区别"></a>3、TCP、UDP协议的区别</h4><h4 id="4、TCP协议如何保证可靠性传输"><a href="#4、TCP协议如何保证可靠性传输" class="headerlink" title="4、TCP协议如何保证可靠性传输"></a>4、TCP协议如何保证可靠性传输</h4><h4 id="5、ARQ协议"><a href="#5、ARQ协议" class="headerlink" title="5、ARQ协议"></a>5、ARQ协议</h4><h4 id="6、滑动窗口和流量控制"><a href="#6、滑动窗口和流量控制" class="headerlink" title="6、滑动窗口和流量控制"></a>6、滑动窗口和流量控制</h4><h4 id="7、拥塞控制"><a href="#7、拥塞控制" class="headerlink" title="7、拥塞控制"></a>7、拥塞控制</h4><h4 id="8、各种协议与HTTP协议之间的关系"><a href="#8、各种协议与HTTP协议之间的关系" class="headerlink" title="8、各种协议与HTTP协议之间的关系"></a>8、各种协议与HTTP协议之间的关系</h4><h4 id="9、HTTP长连接、短链接"><a href="#9、HTTP长连接、短链接" class="headerlink" title="9、HTTP长连接、短链接"></a>9、HTTP长连接、短链接</h4><h4 id="10、HTTP是不保存状态的协议，如何保存用户的状态？"><a href="#10、HTTP是不保存状态的协议，如何保存用户的状态？" class="headerlink" title="10、HTTP是不保存状态的协议，如何保存用户的状态？"></a>10、HTTP是不保存状态的协议，如何保存用户的状态？</h4><h4 id="11、Cookie的作用是什么？和Session有什么区别？"><a href="#11、Cookie的作用是什么？和Session有什么区别？" class="headerlink" title="11、Cookie的作用是什么？和Session有什么区别？"></a>11、Cookie的作用是什么？和Session有什么区别？</h4><h3 id="🌙、数据库"><a href="#🌙、数据库" class="headerlink" title="🌙、数据库"></a>🌙、数据库</h3><h4 id="1、MySQL存储索引"><a href="#1、MySQL存储索引" class="headerlink" title="1、MySQL存储索引"></a>1、MySQL存储索引</h4><h4 id="2、字符集及校验规则"><a href="#2、字符集及校验规则" class="headerlink" title="2、字符集及校验规则"></a>2、字符集及校验规则</h4><h4 id="3、索引"><a href="#3、索引" class="headerlink" title="3、索引"></a>3、索引</h4><h4 id="4、查询缓存的使用"><a href="#4、查询缓存的使用" class="headerlink" title="4、查询缓存的使用"></a>4、查询缓存的使用</h4><h4 id="5、什么是事务"><a href="#5、什么是事务" class="headerlink" title="5、什么是事务"></a>5、什么是事务</h4><h4 id="6、事务的四大特性-ACID"><a href="#6、事务的四大特性-ACID" class="headerlink" title="6、事务的四大特性(ACID)"></a>6、事务的四大特性(ACID)</h4><h4 id="7、并发事务带来哪些问题？"><a href="#7、并发事务带来哪些问题？" class="headerlink" title="7、并发事务带来哪些问题？"></a>7、并发事务带来哪些问题？</h4><h4 id="8、事务隔离级别有哪些？MySQL的默认隔离级别是？"><a href="#8、事务隔离级别有哪些？MySQL的默认隔离级别是？" class="headerlink" title="8、事务隔离级别有哪些？MySQL的默认隔离级别是？"></a>8、事务隔离级别有哪些？MySQL的默认隔离级别是？</h4><h4 id="9、锁机制与InnoDB锁算法"><a href="#9、锁机制与InnoDB锁算法" class="headerlink" title="9、锁机制与InnoDB锁算法"></a>9、锁机制与InnoDB锁算法</h4><h4 id="10、大表优化"><a href="#10、大表优化" class="headerlink" title="10、大表优化"></a>10、大表优化</h4><h4 id="11、解释一下什么池化设计思想。什么事数据库连接池？为什么需要数据库连接池？"><a href="#11、解释一下什么池化设计思想。什么事数据库连接池？为什么需要数据库连接池？" class="headerlink" title="11、解释一下什么池化设计思想。什么事数据库连接池？为什么需要数据库连接池？"></a>11、解释一下什么池化设计思想。什么事数据库连接池？为什么需要数据库连接池？</h4><h4 id="12、分库分表后，id主键如何处理？"><a href="#12、分库分表后，id主键如何处理？" class="headerlink" title="12、分库分表后，id主键如何处理？"></a>12、分库分表后，id主键如何处理？</h4>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jovinbin</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jovinbin.github.io/2023/02/22/java-xue-xi-bi-ji/">https://jovinbin.github.io/2023/02/22/java-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Jovinbin</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                    <span class="chip bg-color">笔记</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/02/22/kafka-an-zhuang/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="kafka安装">
                        
                        <span class="card-title">kafka安装</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-02-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/kafka/" class="post-category">
                                    kafka
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/kafka/">
                        <span class="chip bg-color">kafka</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/12/15/linux-chang-yong-ming-ling/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="Linux 常用命令">
                        
                        <span class="card-title">Linux 常用命令</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-12-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">学习笔记</span>
                    </a>
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <a href="/about" target="_blank">Jovinbin</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">37.4k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Jovinbin" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1097204334@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1097204334" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1097204334" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
